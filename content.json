{"meta":{"title":"Shohret","subtitle":"この世界が間違っている","description":null,"author":"Shohret","url":"https://shohret.github.io"},"pages":[{"title":"about","date":"2017-03-14T04:06:30.000Z","updated":"2018-02-03T04:37:20.000Z","comments":false,"path":"about/index.html","permalink":"https://shohret.github.io/about/index.html","excerpt":"","text":"ئەسسالام ئەلەيكۇم Name: Shohret (شۆھرەت) Ethnicity: Uyghur (ئۇيغۇر) Languages: Uyghur, English, Japanese (N1), Chinese, basic Turkish and Uzbek Loves: anime, manga, learning languages, drawing, calligraphy, coding, art Likes: reading, movies, chess Education: Master of Computer Science"},{"title":"categories","date":"2017-03-14T04:06:01.000Z","updated":"2018-02-03T04:37:05.000Z","comments":false,"path":"categories/index.html","permalink":"https://shohret.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-03-14T04:06:17.000Z","updated":"2018-02-03T04:36:16.000Z","comments":false,"path":"tags/index.html","permalink":"https://shohret.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Trees Implementation","slug":"Trees-Implementation","date":"2018-02-02T04:31:36.000Z","updated":"2018-02-03T04:53:42.000Z","comments":true,"path":"2018/02/01/Trees-Implementation/","link":"","permalink":"https://shohret.github.io/2018/02/01/Trees-Implementation/","excerpt":"Binary Search Tree Average Case Worst Case Space O(n) O(n) Insert O(log(n)) O(n) Delete O(log(n)) O(n) Search O(log(n)) O(n)","text":"Binary Search Tree Average Case Worst Case Space O(n) O(n) Insert O(log(n)) O(n) Delete O(log(n)) O(n) Search O(log(n)) O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129class Node(object): def __init__(self, data): self.data = data self.leftChild = None self.rightChild = Noneclass BinarySearchTree(object): def __init__(self): self.root = None def insert(self, data): if not self.root: self.root = Node(data) else: self.insertNode(data, self.root) # O(logn) if the tree is balanced. If it is not, it can be reduced to O(n) def insertNode(self, data, node): if data &lt; node.data: if node.leftChild: self.insertNode(data, node.leftChild) else: node.leftChild = Node(data) else: if node.rightChild: self.insertNode(data, node.rightChild) else: node.rightChild = Node(data) def remove(self, data): if self.root: self.root = self.removeNode(data, self.root) def removeNode(self, data, node): if not node: return node if data &lt; node.data: node.leftChild = self.removeNode(data, node.leftChild) elif data &gt; node.data: node.rightChild = self.removeNode(data, node.rightChild) else: if not node.leftChild and not node.rightChild: print('Removing a leaf node') del node return None elif not node.leftChild: print('Removing a node with single right child...') tempNode = node.rightChild del node return tempNode elif not node.rightChild: print('Removing a node with single left child...') tempNode = node.leftChild del node return tempNode print('Removing node with two children...') tempNode = self.getProdecessor(node.leftChild) node.data = tempNode.data node.leftChild = self.removeNode(tempNode.data, node.leftChild) return node def getProdecessor(self, node): if node.rightChild: return self.getProdecessor(node.rightChild) return node def getMinValue(self): if self.root: return self.getMin(self.root) def getMin(self, node): if node.leftChild: return self.getMin(node.leftChild) return node.data def getMaxValue(self): if self.root: return self.getMax(self.root) def getMax(self, node): if node.rightChild: return self.getMax(node.rightChild) return node.data def traverse(self): if self.root: self.traverseInOrder(self.root) def traverseInOrder(self, node): if node.leftChild: self.traverseInOrder(node.leftChild) print(node.data) if node.rightChild: self.traverseInOrder(node.rightChild)bst = BinarySearchTree()bst.insert('a')bst.insert('s')bst.insert('b')bst.insert('t')# print(bst.getMaxValue())# print(bst.getMinValue())# bst.remove('s')bst.remove('a')bst.traverse() AVL TreeAVL trees and red-black trees are guaranteed to be balanced, so O(log(n)) is guaranteed. Average Case Worst Case Space O(n) O(n) Insert O(log(n)) O(log(n)) Delete O(log(n)) O(log(n)) Search O(log(n)) O(log(n)) Applications Databases when deletion or insertion are not so frequent, but have to make a lot of look-ups. Red-Black trees are a little bit more popular, as for AVL we have to make several rotations, a little bit slower. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191class Node(object): def __init__(self, data): self.data = data self.height = 0 self.leftChild = None self.rightChild = Noneclass AVL(object): def __init__(self): self.root = None def insert(self, data): self.root = self.insertNode(data, self.root) def insertNode(self, data, node): if not node: return Node(data) if data &lt; node.data: node.leftChild = self.insertNode(data, node.leftChild) else: node.rightChild = self.insertNode(data, node.rightChild) node.height = max(self.calcHeight(node.leftChild), self.calcHeight(node.rightChild)) + 1 return self.settleViolation(data, node) def settleViolation(self, data, node): # four different cases balance = self.calcBalance(node) if balance &gt; 1 and data &lt; node.leftChild.data: print('Left Left heavy situation...') return self.rotateRight(node) elif balance &lt; - 1 and data &gt; node.rightChild.data: print('Right right heavy situation...') return self.rotateLeft(node) # left and right rotation elif balance &gt; 1 and data &gt; node.leftChild.data: print('Left right heavy situation...') node.leftChild = self.rotateLeft(node.leftChild) return self.rotateRight(node) # right and left rotation elif balance &lt; -1 and data &lt; node.rightChild.data: print('Right left heavy situation...') node.rightChild = self.rotateRight(node.rightChild) return self.rotateLeft(node) return node def calcHeight(self, node): if not node: return -1 return node.height # if it returns value &gt; 1, it means it is a left heavy tree --&gt; right rotation # if it returns value &lt; -1, it means it is a right heavy tree --&gt; left rotation def calcBalance(self, node): if not node: return 0 return self.calcHeight(node.leftChild) - self.calcHeight(node.rightChild) def traverse(self): if self.root: self.traverseInOrder(self.root) def traverseInOrder(self, node): if node.leftChild: self.traverseInOrder(node.leftChild) print(node.data) if node.rightChild: self.traverseInOrder(node.rightChild) def rotateRight(self, node): print('Rotating to the right on node', node.data) temLeftChild = node.leftChild t = temLeftChild.rightChild temLeftChild.rightChild = node node.leftChild = t node.height = max(self.calcHeight(node.leftChild), self.calcHeight(node.rightChild)) + 1 temLeftChild.height = max(self.calcHeight(temLeftChild.leftChild), self.calcHeight(temLeftChild.rightChild)) + 1 return temLeftChild def rotateLeft(self, node): print('Rotating to the left on node', node.data) temRightChild = node.rightChild t = temRightChild.leftChild temRightChild.leftChild = node node.rightChild = t node.height = max(self.calcHeight(node.leftChild), self.calcHeight(node.rightChild)) + 1 temRightChild.height = max(self.calcHeight(temRightChild.leftChild), self.calcHeight(temRightChild.rightChild)) + 1 return temRightChild def remove(self, data): if self.root: self.root = self.removeNode(data, self.root) def removeNode(self, data, node): if not node: return node elif data &lt; node.data: node.leftChild = self.removeNode(data, node.leftChild) elif data &gt; node.data: node.rightChild = self.removeNode(data, node.rightChild) else: if not node.leftChild and not node.rightChild: print('Removing a leaf node') del node return None elif not node.leftChild: print('Removing a node with right child...') tempNode = node.rightChild del node return tempNode elif not node.rightChild: print('Removing a node with left child...') tempNode = node.leftChild del node return tempNode print('Removing node with two children...') tempNode = self.getProdecessor(node.leftChild) node.data = tempNode.data node.leftChild = self.removeNode(tempNode.data, node.leftChild) if not node: return node # if the tree has only a single node node.height = max(self.calcHeight(node.leftChild), self.calcHeight(node.rightChild)) + 1 balance = self.calcBalance(node) # doubly left heavy situation if balance &gt; 1 and self.calcBalance(node.leftChild) &gt;= 0: return self.rotateRight(node) # doubly right heavy situation elif balance &lt; -1 and self.calcBalance(node.rightChild) &lt;= 0: return self.rotateLeft(node) # left right case elif balance &gt; 1 and self.calcBalance(node.leftChild) &lt;= 0: node.leftChild = self.rotateLeft(node.leftChild) return self.rotateRight(node) # right left case elif balance &lt; -1 and self.calcBalance(node.rightChild) &gt; 0: node.rightChild = self.rotateRight(node.rightChild) return self.rotateLeft(node) return nodeavl = AVL()avl.insert(10)avl.insert(20)avl.insert(5)avl.insert(4)avl.insert(15)avl.remove(5)avl.remove(4)avl.traverse() Red-Black Tree Average Case Worst Case Space O(n) O(n) Insert O(log(n)) O(log(n)) Delete O(log(n)) O(log(n)) Search O(log(n)) O(log(n)) Red-Black tree properties: Each node is either red or black The root node is always black Every red most have two black child nodes and no other children -&gt; it must have a black parent Every path from a given node to any of its descendant Null nodes contains the same number of black nodes. Tries &amp; Ternary Search TreeHash Table VS Tries We can replace hash tables with tries, tries are more efficient for search misses Hash table the key is going to be converted into an index with the help of the hash function Tries, we consider every single character of the key, but we return right when there is a mismatch. For tries there is no collision. Tries can provide string, so alphabetical ordering of the entries by keys. Hash table does not. No hash function needed for tries. Applications Predictive text, auto-complete feature Spell checking 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Node(object): def __init__(self, character): self.character = character self.leftNode = None self.midNode = None self.rightNode = None self.value = 0class TST(object): def __init__(self): self.rootNode = None def put(self, key, value): self.rootNode = self.putItem(self.rootNode, key, value, 0) def putItem(self, node, key, value, index): c = key[index] if node is None: node = Node(c) if c &lt; node.character: node.leftNode = self.putItem(node.leftNode, key, value, index) elif c &gt; node.character: node.rightNode = self.putItem(node.rightNode, key, value, index) elif index &lt; len(key) - 1: node.midNode = self.putItem(node.midNode, key, value, index + 1) else: node.value = value return node def get(self, key): node = self.getItem(self.rootNode, key, 0) if node is None: return -1 # means given key is not present in the dictionary return node.value def getItem(self, node, key, index): if node is None: return None c = key[index] if c &lt; node.character: return self.getItem(node.leftNode, key, index) elif c &gt; node.character: return self.getItem(node.rightNode, key, index) elif index &lt; len(key) - 1: return self.getItem(node.midNode, key, index + 1) else: return nodeif __name__ == \"__main__\": tst = TST() tst.put('apple', 100) tst.put('orange', 200) print(tst.get('apple'))","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://shohret.github.io/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"https://shohret.github.io/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://shohret.github.io/tags/data-structure/"},{"name":"Python","slug":"Python","permalink":"https://shohret.github.io/tags/Python/"},{"name":"AVL","slug":"AVL","permalink":"https://shohret.github.io/tags/AVL/"},{"name":"BST","slug":"BST","permalink":"https://shohret.github.io/tags/BST/"},{"name":"tree","slug":"tree","permalink":"https://shohret.github.io/tags/tree/"}]},{"title":"How to Use ~ば","slug":"How-to-Use-ba-Particle","date":"2018-01-30T01:27:46.000Z","updated":"2018-02-03T04:50:14.000Z","comments":true,"path":"2018/01/29/How-to-Use-ba-Particle/","link":"","permalink":"https://shohret.github.io/2018/01/29/How-to-Use-ba-Particle/","excerpt":"The conditional 〜ば form changes differently in these word types: 『動詞』(verb)、『い形容詞』(i adjective)、『な形容詞』(na adjective)、そして『名詞』(noun)。And 『動詞』(verb) will include three different categories: u verb, ru verb, and exceptions.","text":"The conditional 〜ば form changes differently in these word types: 『動詞』(verb)、『い形容詞』(i adjective)、『な形容詞』(na adjective)、そして『名詞』(noun)。And 『動詞』(verb) will include three different categories: u verb, ru verb, and exceptions. 動詞う動詞U verb is also called 「五段動詞』. When we change it to ~ば conditional form, we need to change it from u sound to e sound. (う段からえ段へ). And then add a ば at the end. 例：会う あう → あえば歩く あるく → あるけば出す だす → だせば待つ まつ → まてば死ぬ しぬ → しねば飛ぶ とぶ → とべば頼む たのむ → たのめば在る ある → あれば る動詞Ru verb is always easy to change. To change it to 〜ば conditional form, we just need to replace る with れば。 例：入れる いれる → いれれば浴びる あびる → あびれば教える おしえる → おしえれば並べる ならべる → ならべれば 『する』『くる』する → すれば例：勉強する → 勉強すれば くる → くれば い形容詞To convert い adjective to conditional form, we need to remove い, then add ければ at the end. 例：おいしい → おいしければいそがしい → 忙しければおおい → おおければたかい → たかければPlease note, there is one exception in い adjective. When adjective いい changes to conditional form, いい will change to 良い（よい）, then remove い、add ければ.いい → 良ければ よければ な形容詞Let’s put な adjective and noun together, as most of the case な adjective always comes before a noun. And we usually don’t use 〜ば after a な adjective or verb. Instead, we use 『なら』 after a noun.『なら』is also a condition auxiliary, means if; in case;. You can check it more from here. 例：北海道 → 北海道ならＮ１ → Ｎ１ならにぎやか → にぎやかなら簡単 → 簡単なら Negative / 否定To make a negative condition, we just need to change all original forms to the negative ない form, then change ない to なければ. 例：彼だ → 彼じゃない → 彼じゃなければ静かだ → 静かじゃない → 静かじゃなければおいしい → おいしくない → おいしくなければ行く → 行かない → 行かなければ 練習You can try to change following words to conditional form. たいへん たのしい 読む 本屋 小さい いる（存在動詞） 200グラム 寒い 呼ぶ 捨てない 疲れている 出張する 立派 いい 使う Reference:正樹日本語","categories":[{"name":"Language","slug":"Language","permalink":"https://shohret.github.io/categories/Language/"},{"name":"Japanese","slug":"Language/Japanese","permalink":"https://shohret.github.io/categories/Language/Japanese/"}],"tags":[{"name":"grammar","slug":"grammar","permalink":"https://shohret.github.io/tags/grammar/"},{"name":"Japanese","slug":"Japanese","permalink":"https://shohret.github.io/tags/Japanese/"}]},{"title":"Stack & Queue Implementation","slug":"Stack-Queue-Implementation","date":"2018-01-17T05:16:59.000Z","updated":"2018-02-03T04:53:09.000Z","comments":true,"path":"2018/01/16/Stack-Queue-Implementation/","link":"","permalink":"https://shohret.github.io/2018/01/16/Stack-Queue-Implementation/","excerpt":"Stack and queue abstract data types implementation with Python. Stack LIFO structure Graph algorithm: depth-first search can be implemented with Stack Finding Euler-cycles in a Graph Finding strongly connected components in a graph If we use recursion, the OS will use stacks","text":"Stack and queue abstract data types implementation with Python. Stack LIFO structure Graph algorithm: depth-first search can be implemented with Stack Finding Euler-cycles in a Graph Finding strongly connected components in a graph If we use recursion, the OS will use stacks Most important application of stacks: stack memory it is a special region of the memory (in the RAM) it keeps track of the point to which each active subroutine should return control when it finishes executing store temporary variables created by each function stack memory is limited Heap Memory The heap is a region that is not automatically arranged for you This is a large region of memory, unlike stack memory C: malloc() and calloc() function, with pointers Java: reference types and objects are on the Heap We have to deallocate these memory chunks as it it not managed automatically. If not, memory leak! Slower than stack memory because of pointers stack memory heap memory limited in size no size limit fast access slow access local variables objects space is managed efficiently by CPU memory may be fragmented variables cannot be resized variables can be resized // realloc() Queue FIFO structure It can be implemented with linked lists application: BFS Operational research applications or stochastic models relies heavily on queues ImplementationStack12345678910111213141516171819202122232425262728293031323334353637383940# stack is an abstract data type (interface), LIFO# there are 3 operations: push(), pop(), peek()class Stack: def __init__(self): self.stack = [] def isEmpty(self): return self.stack == [] def push(self, data): self.stack.append(data) def pop(self): data = self.stack[-1] del self.stack[-1] return data def peek(self): return self.stack[-1] def sizeStack(self): return len(self.stack)# teststack = Stack()stack.push(1)stack.push(2)stack.push(3)print(stack.sizeStack())print('popped: ', stack.pop())print(stack.sizeStack())print('peeked: ', stack.peek())print(stack.sizeStack()) Queue1234567891011121314151617181920212223242526272829303132333435363738394041# queue is an abstract data type (interface) FIFO# operations: enqueue(), dequeue(), peek()# e.g: CPU scheduling, IO bufferclass Queue: def __init__(self): self.queue = [] def isEmpty(self): return self.queue == [] def enqueue(self, data): self.queue.append(data) def dequeue(self): data = self.queue[0] del self.queue[0] return data def peek(self): return self.queue[0] def sizeQueue(self): return len(self.queue)# testqueue = Queue()queue.enqueue(1)queue.enqueue(2)queue.enqueue(3)queue.enqueue(4)print('dequeue: ', queue.dequeue())print(queue.sizeQueue())print('peek: ', queue.peek())print(queue.sizeQueue())","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://shohret.github.io/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"https://shohret.github.io/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://shohret.github.io/tags/data-structure/"},{"name":"Python","slug":"Python","permalink":"https://shohret.github.io/tags/Python/"},{"name":"queue","slug":"queue","permalink":"https://shohret.github.io/tags/queue/"},{"name":"stack","slug":"stack","permalink":"https://shohret.github.io/tags/stack/"}]},{"title":"Linked Lists Implementation","slug":"Linked-Lists-Python","date":"2018-01-16T00:04:32.000Z","updated":"2018-02-03T04:52:37.000Z","comments":true,"path":"2018/01/15/Linked-Lists-Python/","link":"","permalink":"https://shohret.github.io/2018/01/15/Linked-Lists-Python/","excerpt":"Advantage Linked Lists are dynamic data structures, arrays are not It can allocate the needed memory in runtime Very efficient if we want to manipulate the first elements Can store items with different sizes; an array assumes every element to be exactly the same It is easier for a linked list to grow organically. An array’s size usually need to be known ahead of time or re-created when it needs to grow","text":"Advantage Linked Lists are dynamic data structures, arrays are not It can allocate the needed memory in runtime Very efficient if we want to manipulate the first elements Can store items with different sizes; an array assumes every element to be exactly the same It is easier for a linked list to grow organically. An array’s size usually need to be known ahead of time or re-created when it needs to grow Disadvantages Waste memory because of the references Nodes in a linked list must be read in order from the beginning as linked lists have sequential access (array items can be reached via indexes in O(1) time) Solution: doubly linked lists -&gt; easier to read, but memory is wasted in allocating space for a back pointer Pros &amp; Cons of an array Pros We can use random access by indexes, O(1) Very fast implementation and use Very fast data structure A good choice when we want to add items over and over again and we want to get items with given indexes Cons Usually, we have to know the size of the array at compile time If it is full we have to create a bigger array and have to copy values one by one. It is not able to store items with different types (Not the case in Python) Linked Lists vs Arrays Linked Lists Arrays search O(n) O(1) via index insert at the start O(1) O(N) insert at the end O(N) O(1) Waste Space O(N) 0 ImplementationLinked List implementation with Python123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class Node(object): def __init__(self, data): self.data = data self.nextNode = Noneclass LinkedList(object): def __init__(self): self.head = None self.size = 0 # O(1) def insertStart(self, data): self.size = self.size + 1 newNode = Node(data) if not self.head: self.head = newNode else: newNode.nextNode = self.head self.head = newNode def remove(self, data): if self.head is None: return self.size = self.size - 1 currentNode = self.head previousNode = None while currentNode.data != data: previousNode = currentNode currentNode = currentNode.nextNode if previousNode is None: self.head = currentNode.nextNode else: previousNode = currentNode.nextNode # O(1) def size1(self): return self.size # O(N) not good !!!!! def seize2(self): actualNode = self.head size = 0 while actualNode is not None: size += 1 actualNode = actualNode.nextNode return size # O(N) def insertEnd(self, data): self.size = self.size + 1 newNode = Node(data) actualNode = self.head while actualNode.nextNode is not None: actualNode = actualNode.nextNode actualNode.nextNode = newNode def traverseList(self): actualNode = self.head while actualNode is not None: print('%d ' % actualNode.data) actualNode = actualNode.nextNode# testlinkedList = LinkedList()linkedList.insertStart(12)linkedList.insertStart(122)linkedList.insertStart(3)linkedList.insertEnd(5)linkedList.traverseList()linkedList.remove(3)linkedList.remove(5)linkedList.remove(122)print(linkedList.size1()) Other Note abstract data types data structures Stack array, linked list Queue array, linked list Priority queue heap Dictionary / hashmap array","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://shohret.github.io/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"https://shohret.github.io/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://shohret.github.io/tags/data-structure/"},{"name":"Python","slug":"Python","permalink":"https://shohret.github.io/tags/Python/"},{"name":"array","slug":"array","permalink":"https://shohret.github.io/tags/array/"},{"name":"linked list","slug":"linked-list","permalink":"https://shohret.github.io/tags/linked-list/"}]},{"title":"Duolingo Turkish Notes 1","slug":"Duolingo-Turkish-Notes-1","date":"2017-08-31T19:41:04.000Z","updated":"2018-02-03T04:49:38.000Z","comments":true,"path":"2017/08/31/Duolingo-Turkish-Notes-1/","link":"","permalink":"https://shohret.github.io/2017/08/31/Duolingo-Turkish-Notes-1/","excerpt":"It is been one week start learning Turkish on duolingo. Since Turkish is originated from my mother tongue, grammar part is easy for me. But still, need to remember some vocabs. To make it easier to review, I wanted to make a note here.","text":"It is been one week start learning Turkish on duolingo. Since Turkish is originated from my mother tongue, grammar part is easy for me. But still, need to remember some vocabs. To make it easier to review, I wanted to make a note here. BasicVocabelma: applesu: waterbir: a / anekmek: breadyemek: eatve: andiçmek: drinkveya: orkız: girlerkek: man (gender)adam: mankadın: woman (gender)süt: milksandviç: sandwich Grammarpronouns Singular Plural 1st Person Ben Biz 2nd Person Sen Siz 3rd Person O Onlar Common PhrasesVocabteşekkürler: thank youmerhaba: hellomemnun oldum: nice to meet youhoşçakal: byeiyi akşamlar: good eveninghayır: nogörüşürüz: nice to meet youiyi geceler: good nightevet: yesiyi şanslar: good luckaffedersin: execuse me:günaydın: good morninggüle güle: goodbyerica ederim: you’re welcomebiliyorum: I knowtürkçe: Turkishingilizce: Englishlütfen: pleasebilmiyorum: I don’t knowselam: Hihoş geldin: welcomehoş geldiniz: welcome (formal way)iyiyim: I am goodnasılsın: how are you?nasılsınız: how are you (formal way)tamam: alright Adjectives 1Vocabsıcak: hotsoğuk: coldçok: verygenç: younggüzel: beautifulyaşlı: old, eldereski: oldbu: thisşu: thatbunlar: theseşunlar: thosezor: difficultkolay: easybüyük: bigküçük: small, little FoodVocabkahve: coffeeportakal: orange (noun)makarna: pastayumurta: eggşeker: sugarpasta: cakeçilek: strawberrypeynir:cheesebalık: fishmeyve: fruitçay: teaet: meat, beefyağ: oillimon: lemonçorba: soupdomates: tomatosbira: beertavuk: chickenşarap: winetuz: salt AccusativeVocabmenü: menukolay gelsin: good luck / may it be easyGrammar Turkish English Ben gazete okurum. I read newspapers. or I read a newspaper. Ben gazeteyi okurum. I read the newspaper. Ben bir gazete okurum. I read a newspaper. Vowel Harmony Turkish Accusative Suffix ö, ü -(y)ü o,u -(y)u e,i -(y)i a,ı -(y)ı If the noun ends in a vowel, you have to insert the buffer letter y. Here are some examples: Turkish, Nominative Turkish, Accusative English elma elmayı apple gazete gazeteyi newspaper süt sütü milk limon limonu lemon Consonant Mutations Turkish, Nominative Turkish, Accusative English kitap kitabı book ağaç ağacı tree köpek köpeği dog This means:p → bt → dk → ğç → c AnimalsVocabköpek: dogkedi: catkuş: birdkaplumbağa: turtlekurbağa: frogkuzu: lambkoyun: sheepörümcek: spiderayı: bearfil: elephantfare: mouseaslan: lionhindi: turkeytavşan: rabbitbaykuş: owlördek: duckyengeç: crabat: horseinek: cow PluralGrammarForming the plural in Turkish is simple compared to the Accusative case. It is formed using the suffix -lAr. Now you might be thinking, “what is that capital A doing there?” to which we respond with 2-way vowel harmony. This is the other form of vowel harmony found in Turkey suffixes. Basically if the final vowel is front (i, e, ü, ö) use -ler. If it is back (a, ı, o, u), use the suffix -lar. This rule along with the rule for 4-way vowel harmony will be used in several suffixes across Turkish Grammar, so try to get used to it now. Turkish, Nominative English Turkish, Plural English ayı bear ayılar bears kuş bird kuşlar birds kurbağa frog kurbağalar frogs köpek dog köpekler dogs hindi turkey hindiler turkeys menü menu menüler menus To beCopula Suffix Person/Number Example English -(y)Im 1st sing. (Ben) mutluyum. I am happy. -sIn 2nd sing. (Sen) mutlusun. You are happy. ∅, -DIr 3rd sing O mutlu. He/She/It is happy. -(y)Iz 1st pl. (Biz) mutluyuz. We are happy. -sInIz 2nd pl. (Siz) mutlusunuz. You are happy. ∅, -DIr 3rd pl. Onlar mutlu/mutludur. They are happy. -lAr, -DIrlAr 3rd pl. (Onlar) mutlular/mutludurlar. They are happy. There are a few points to talk about in the above chart. All except the 3rd person pl. suffix follow 4-way vowel harmony. In the 1st person, you will see a buffer “-y-” be used if the adjective or noun ends in a vowel. The suffix -DIr is used to clarify any ambiguity, emphasize, or state facts. This both follows 4-way vowel harmony and has consonant harmony; ‘d’ changes to ‘t’ after the following consonants (p ç t k s ş h f). The suffix -lAr is optional in the 3rd person pl. However, it is only optional when referring to people. This suffix may not be used for items and animals. Only humans!","categories":[{"name":"Language","slug":"Language","permalink":"https://shohret.github.io/categories/Language/"},{"name":"Turkish","slug":"Language/Turkish","permalink":"https://shohret.github.io/categories/Language/Turkish/"}],"tags":[{"name":"duolingo","slug":"duolingo","permalink":"https://shohret.github.io/tags/duolingo/"},{"name":"Turkish","slug":"Turkish","permalink":"https://shohret.github.io/tags/Turkish/"}]},{"title":"Drawing and Song - Tokyo Ghoul","slug":"Drawing-and-Song-Tokyo-Ghoul","date":"2017-08-02T03:37:51.000Z","updated":"2018-02-03T04:51:07.000Z","comments":true,"path":"2017/08/01/Drawing-and-Song-Tokyo-Ghoul/","link":"","permalink":"https://shohret.github.io/2017/08/01/Drawing-and-Song-Tokyo-Ghoul/","excerpt":"Today I want to share a piece of my drawing and a song of Tokyo Ghoul new movie. The character in the drawing is Kirishima Touka (霧島トーカ), from anime Tokyo Ghoul.","text":"Today I want to share a piece of my drawing and a song of Tokyo Ghoul new movie. The character in the drawing is Kirishima Touka (霧島トーカ), from anime Tokyo Ghoul. And below is the song of Tokyo Ghoul new movie, I like it, the lyric is attached below as well. 「Banka」illion - Tokyo Ghoul 言葉でなんか救えないそんな思いに抱かれしまった全世界が手を繋ぎ僕の行く手を通せんぼする 子供ながらについたあの一世一代の嘘のツケが今になって降ってきたの得意の許され方も通じない 声が聞こえるでしょう知っていたはずだよ悲しみが来た場所君が背をいつも向ける方 愛に凭れないで愛を語らないで無理に振りかざしたりはしないでよなんですぐ頼るのなんで寄りかかるのそんな曖昧なもので片目を塞がないで 同じ酸素を吸ってるのにもう同じ息を吐けない枯れるまでが花なのなら最後までちゃんと燃やすよ 声で交わすよりも手を握りる方がわかることがあるよだから僕らはその手を離すのお喋りが好きなの 愛に凭れないで愛を語らないで無理に振りかざしたりはしないでよなんですぐ頼るのなんで寄りかかるの一生費やしても解ける定理に 愛より大きな声で君は歌う夢より微かな光の中で舞うたとえどれだけその光が醜く輝いていたってさ僕ら選ばれてしまった 愛より大きな声で君は歌う夢より微かな光の中で舞うたとえこの身体も世界も 僕を頑なに拒んでも僕は明日を選ぶ 愛より大きな声で君は歌う夢より微かな光の中で舞うたとえどれだけその光が醜く輝いていたってさ僕ら選ばれてしまった","categories":[{"name":"Art","slug":"Art","permalink":"https://shohret.github.io/categories/Art/"}],"tags":[{"name":"Japanese","slug":"Japanese","permalink":"https://shohret.github.io/tags/Japanese/"},{"name":"anime","slug":"anime","permalink":"https://shohret.github.io/tags/anime/"},{"name":"art","slug":"art","permalink":"https://shohret.github.io/tags/art/"},{"name":"drawing","slug":"drawing","permalink":"https://shohret.github.io/tags/drawing/"},{"name":"song","slug":"song","permalink":"https://shohret.github.io/tags/song/"},{"name":"Tokyo Ghoul","slug":"Tokyo-Ghoul","permalink":"https://shohret.github.io/tags/Tokyo-Ghoul/"}]},{"title":"Very Simple Android App - MathSucks","slug":"Very-Simple-Android-App-MathSucks","date":"2017-07-30T21:22:39.000Z","updated":"2018-02-03T04:54:49.000Z","comments":true,"path":"2017/07/30/Very-Simple-Android-App-MathSucks/","link":"","permalink":"https://shohret.github.io/2017/07/30/Very-Simple-Android-App-MathSucks/","excerpt":"Just want to make a note for this very simple android app, which does percentages. Even though this is super simple, I still had a problem when I run it😅. The problem I had is every TextView, Button, EditText aligned to top left side of the screen. I checked the property of them, all center, it is supposed to work.","text":"Just want to make a note for this very simple android app, which does percentages. Even though this is super simple, I still had a problem when I run it😅. The problem I had is every TextView, Button, EditText aligned to top left side of the screen. I checked the property of them, all center, it is supposed to work.Then, I realized the default layout is ConstraintLayout, and I tried to change it to RelativeLayout, every widget on the design screen went back to top left side. I dragged them back to the center, aligned them vertically, tried to run it. It worked~~~. Code edited in MainActivity.java1234567891011121314151617181920212223242526272829public class MainActivity extends AppCompatActivity &#123; TextView totalTextView; EditText percentageTxt; EditText numberTxt; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); totalTextView = (TextView) findViewById(R.id.totalTextView); percentageTxt = (EditText) findViewById(R.id.percentageTxt); numberTxt = (EditText) findViewById(R.id.numberTxt); Button calcBtn = (Button) findViewById(R.id.calcBtn); calcBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick (View view) &#123; float percentage = Float.parseFloat(percentageTxt.getText().toString()); float dec = percentage / 100; float total = dec * Float.parseFloat(numberTxt.getText().toString()); totalTextView.setText (Float.toString(total)); &#125; &#125;); &#125; Demo Screens","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://shohret.github.io/categories/Computer-Science/"},{"name":"App Development","slug":"Computer-Science/App-Development","permalink":"https://shohret.github.io/categories/Computer-Science/App-Development/"}],"tags":[]},{"title":"نى يېڭىلاش Github Credentials","slug":"Updating-Credentials-of-Github-in-Uyghur","date":"2017-04-07T18:13:04.000Z","updated":"2018-02-03T04:54:08.000Z","comments":true,"path":"2017/04/07/Updating-Credentials-of-Github-in-Uyghur/","link":"","permalink":"https://shohret.github.io/2017/04/07/Updating-Credentials-of-Github-in-Uyghur/","excerpt":"ئەسسالام ئەلەيكۇم تۈنۈگۈن كەچ Github تىكى ھېساۋات نامىمنى ئۆزگەرتكەنىدىم. Github دا ھېسھۋات نامىمنى ئۆزگەرتكەندىنكېن باشتا قۇرغان بەزى ئامبار ۋە گېتخاب بېتىنىڭمۇ url ئادىرسىنىمۇ ئۆزگەرتىش كېرەك ئ‍ىدى. مەن ئۇلانىڭ ھەممىنى ئۆزگەرتىپ ئادىن كومپۇتۇرۇمدىكى hexo بلوگىمنىمۇ تەڭشىدىم. ئاقىدا hexo نى گېتخابقا چىقارماقچى بولغاندا كۈتۈلمىگەن مەسىلىگە يولۇقتۇم. بۇيرۇق كۆزنىكىدە تۆۋەندىكى خاتالىق چىقىۋېلىپ، كومپيۇتىردىكى ئارخىپنى github قا يوللىيالمىدىم. بۇ دېمەك كومپۇتۇرۇم ۋە گىتخابنىڭ ئۇلىنىشىدا مەسەلە كۆرۈلگەنىدى.","text":"ئەسسالام ئەلەيكۇم تۈنۈگۈن كەچ Github تىكى ھېساۋات نامىمنى ئۆزگەرتكەنىدىم. Github دا ھېسھۋات نامىمنى ئۆزگەرتكەندىنكېن باشتا قۇرغان بەزى ئامبار ۋە گېتخاب بېتىنىڭمۇ url ئادىرسىنىمۇ ئۆزگەرتىش كېرەك ئ‍ىدى. مەن ئۇلانىڭ ھەممىنى ئۆزگەرتىپ ئادىن كومپۇتۇرۇمدىكى hexo بلوگىمنىمۇ تەڭشىدىم. ئاقىدا hexo نى گېتخابقا چىقارماقچى بولغاندا كۈتۈلمىگەن مەسىلىگە يولۇقتۇم. بۇيرۇق كۆزنىكىدە تۆۋەندىكى خاتالىق چىقىۋېلىپ، كومپيۇتىردىكى ئارخىپنى github قا يوللىيالمىدىم. بۇ دېمەك كومپۇتۇرۇم ۋە گىتخابنىڭ ئۇلىنىشىدا مەسەلە كۆرۈلگەنىدى.كۆرۈلگەن مەسىلە: 12FATAL remote: Permission to NewUsername/NewUername.github.io.git denied to Oldusername.fatal: unable to access 'https://github.com/NewUsername/NewUsername.github.io.git/': The requested URL returned error: 403 بۇ مەسەلە ئادەتتە Github تىكى ھېساۋات نامىڭىزنى ئۆزگەتكەندە ۋەياكى بورۇنقىغا ئوخشىمايدىغان گېتخاب ئادىرسىڭىزنى ئىشلەتكەندە كۆرۈلىدۇ. بۇنى ئوڭشاش ئۈچۈن Mac ۋە Windows سېستىمىسىدىكى ئۇسۇللار تۆۋەندىكىچە: Mac1-ئۇسۇل Finder دىن Keychain Access ئەپنى ئىزدەڭ Keychain Access دىن github.com نى ئىزدەڭ ئاندىن شۇكۆزنەكنى ئىشلەتمەكچى بولغان گېتخاب ھېساۋاتىڭىزغا ئاساسەن ئۆزگەرتىش كىرگۈزسىڭىز بولىدۇ. 2-ئۇسۇلسىز terminal ئارقىلىىقمۇ بۇ ئىشەنچە شېفىرىنى ئۈچۈرىۋېتەلەيسىز، ئاندىن سىز گېتخابدا push قىلغاندا ھېساۋات نامىڭىز بىلەن مەخپى-شېفېرىڭىز قايتا سورىلىدۇ.شۇ ۋاقىتتا يېڭىلاتسىڭىزمۇ بولىدۇ. بۇنى قىلىش ئۈچۈن تۆۋەندىكى بۇيرۇقنى كىرگۈزۈڭ. 1234git credential-osxkeychain erasehost=github.comprotocol=https[Press Return] گېتخابدىكى ئېنگىلىىسچە ئەسلى ماتىريالنى كۆرمەكچى بولسىڭىز بۇيەنى چېكىڭ. WindowsWindows تا بىز Credential Manager نى ئىزدەپ github.com نى ئۆچۈرىۋېتىمىز، ئاندىن گېتخابنى ئىشلەتكەندە ھېساۋات-نام بىلەن شېفىر قايتا سورىلىدۇ، يېڭى گېتخاب ئادىرسىڭىز بويىنچە كىرگۈزسىڭىز بولىدۇ. سولتەرەپ تەكتىدىكى ئىزدەش كۆزنىكىدىن Credential Manager نى ئىزدىپ Windows Credential نى تاللاپ github.com نى ئۆچۈرىۋەتسىڭىز بولىدۇ.","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"https://shohret.github.io/categories/Computer-Science/"},{"name":"Others","slug":"Computer-Science/Others","permalink":"https://shohret.github.io/categories/Computer-Science/Others/"}],"tags":[{"name":"git","slug":"git","permalink":"https://shohret.github.io/tags/git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://shohret.github.io/tags/GitHub/"},{"name":"Uyghur","slug":"Uyghur","permalink":"https://shohret.github.io/tags/Uyghur/"}]},{"title":"ياپونتىلىنى ئۆگېنىش ھەققىدە","slug":"How-to-Learn-Japanese","date":"2017-03-29T04:12:23.000Z","updated":"2018-02-03T04:52:02.000Z","comments":true,"path":"2017/03/28/How-to-Learn-Japanese/","link":"","permalink":"https://shohret.github.io/2017/03/28/How-to-Learn-Japanese/","excerpt":"ئەسسالام ئەلەيكۇم گۆدەك چاغلىرىمدىن باشلاپ تاھازىرغىچە ياپۇنىيەنىڭ كارتۇن فىلىمىنى (ئانىمې) كۆرۈپ كەلدىم. ھەمدە ئانىمې مىنىڭ ھاياتىمغا نۇرغۇن تەرەپلەردىن تەسىر قىلدى، مۇشۇ ئانىمېنى كۈرۈش جەريانىدا ياپون تىلىنىمۇ ئۆگەندىم. شۇڭا بۈگۈن ياپون تىلىنى ئۆگۈنۈشكە ئائىت ئۆزەمنىڭ قارىشىمنى سۆزلەپ ئۆتمەكچىمەن.","text":"ئەسسالام ئەلەيكۇم گۆدەك چاغلىرىمدىن باشلاپ تاھازىرغىچە ياپۇنىيەنىڭ كارتۇن فىلىمىنى (ئانىمې) كۆرۈپ كەلدىم. ھەمدە ئانىمې مىنىڭ ھاياتىمغا نۇرغۇن تەرەپلەردىن تەسىر قىلدى، مۇشۇ ئانىمېنى كۈرۈش جەريانىدا ياپون تىلىنىمۇ ئۆگەندىم. شۇڭا بۈگۈن ياپون تىلىنى ئۆگۈنۈشكە ئائىت ئۆزەمنىڭ قارىشىمنى سۆزلەپ ئۆتمەكچىمەن. ياپون تىلى ھەققىدەياپون تىلى بولسا ئۇيغۇرتىلىغا ئوخشاش ئالتاي تىل سىستىمىسىغا تەۋە، ۋىكىپېدىيادا بۇنىڭدىن سىرت يەنە ياپونىك (Japonic) تىل سىستىمىسى دەپمۇ چۈشەندۈرۈپتۇ. ئاناتىلى ئۇيغۇرتىلى بولغان بىز ئۈچۈن ياپون تىلىنى ئۆگۈنۈش خېلىلا ئوڭاي، چۈنكى ياپون تىلىنىڭ جۈملە قۇرۇلمىسىمۇ ئۇيغۇرچىغا ئوخشاش ئگە + تولدۇرغۇچى + پىئىل شەكلىدە قۇرۇلىدۇ. شۇڭلاشقا مېڭىمىزدە تەپەككۈر قىلغاندىكى تەپەككۈر تىلىمىز، يەنى ئۇيغۇرتىلىغىمۇ ماس كېلىدۇ. يەنە كېلىپ بىز خەنزۇ تىلىنىمۇ بىلگەشكە يېزىش ئوقۇش جەھەتتىنمۇ غەرىپ ئەللىرىدىكىلەرگە قارىغاندا ئارتۇقچىلىقىمىز بار. مەقسەت ۋە ھەيدىگۈچسىز ياپۇنتىلىنى ئۆگەنمەكچى بولدىڭىز، ياخشى. تىل ئۆگىنىش بولسا بىر ئۇزۇن مەزگىللىك جەريان. شۇڭا ئۆزىڭىزنىڭ ياپۇن تىلىنى ئۆگۈنۈشتىكى مەقسەتنى ئايدىڭ قىلىپ، ئاندىن ئۆزىڭىزنى ھەيدەپ تۇرۇپ، پىلانىڭىز بىلەن مېڭىپ ئۆگىنىڭ. قىىزىقىش بولسا ئەڭ ياخشى ھەيدىگۈچى كۈچ، بىر ئىقتىدارنى ئۆگۈنۈش جەريانىدا چىن-كۆڭلىڭىزدىن قىزىقسىڭىز ناھايىتى ياخشى ئۆگىنىپ كىتەلەيسىز. ئەلۋەتتە باشقا سىرىتقى ھەيدىگۈچمۇ بولىدۇ، مەسىلەن خىزمەت سەۋەپلىك، مەكتەپتىكى دەرىسلىك سەۋەپلىك دىگەندەك. سىرىتقى سەۋەپلەردىنمۇ ئەلۋەتتە قىزىقىش ھاسىل قىلغىلى بولىدۇ. قۇرۇق گەپنىمۇ جىق قىلدىم، تۆۋەندە تۇرلۇك ماتىرياللارنى چۇشەندۈرۈپ ئۆتەي.😁 ماتىريالدەرىسلىك كىتابمەن みんなの日本語، &lt;&lt;كۆپچىلىكنىڭ ياپونتىلى&gt;&gt; (大家的日语) دىگەن كىتابنى تەۋسىيە قىلىمەن. بۇ كىتابنى ياپوننىڭ تىل مەكتەپلىرىدىمۇ ئۇزۇن يىللاپ قوللىنىپ كەلگەن، بۇرۇن مەن تونۇيدىغان ياپونلۇق مۇئەللىممۇ بۇ كىتابنى بەك ماختايتى، خەنلە چىقاغان ئۆلچەملىك ياپون تىلى(标准日本语) دىگەن كىتابنى ئۇمۇئەللىم قەتتى ياختۇرمايتى. みんなの日本語 جەمى ئىككى قىسىم بولۇپ، ھەربىر قىسمىنىڭ تېكىسىت كىتابى بىلەن ئوقۇغۇچى پايدىلىنىش كىتابى دەپ ئىككى كىتابى بار، جەمى 4 كىتاب بولىدۇ. تېكىسىت كىتىبى تولۇق ياپونچە يېزىلغان تېكىسىت بولۇپ، ئوقۇغۇچى پايدىلىنىش كىتابىدا شۇ تېكىسىت كىتىبىدىكى دىئالوگنىڭ تەرجىمىسى، ئۇچرىغان خام سۆزلەرنىڭ چۇشەندۇرۇلىشى، ۋە گىراماتىكا بار، ئنتايىن چۈشەنچىلىك. سۆزلۈكنىمۇ باشلاشتا مۇشۇ كىتابدىكى سۆزلەرنىلا يادىلىسىڭىز بولىدۇ. ئاندىن فىلىم كۆرگەندە چۈشەنمىگەن ۋەياكى ياختۇرغان سۆز-جۈملىلەرنى خاتىرلىۋالسىڭىز سۆزلۈكىڭىزنى تېخىمۇ مول قىلىدۇ. ئاڭلاش-كۆرۈشيانفۇنىڭىزغا 沪江听力酷 دىگەن ئەپنى چۇشۇرۇپ ئىشلەتسىڭىز بولىدۇ، ھەرخىل تىلنىڭ ھەرخىل تېمىدىكى ئاۋازلىق ماتىرياللىرىنى تاپالايسىز، قولايلىق، مەن ئۆزۇم بۇرۇن مۇشۇنى ئىشلىتەتتىم. ئاندىن みんなの日本語 نىڭ CD دىسكىسىنىمۇ ئاڭلاپ بېرىڭ. ئىسىمدە قېلىشچە 沪江听力酷 دىنمۇ みんなの日本語 نىڭ ئاۋازلىق ماتېريالىنى تاپقىلى بولىدۇ. قوشتىللىق (ياپونچە ۋە خەنزۇچە) خېتى بار ئانىمې ياكى تېلۋىزىيە تېياتىرلىرىنى خېلى جىق توربەتلەردىن تاپقىلى بولىدۇ. مەن ئادەتتە ئانىمې كۆگەشكە ئانىمېگە ئائىتنىلا بىلىدىكەنمە. ئانىمېنىڭ ھەرخىل تىپتىكى ژانراسى بولىدۇ، بۇرۇن كۆرۈپ باقمىغان بولسىڭىزمۇ مىنىڭچە سىز ياختۇردىغان ئانىمې چوقۇم چىقىدۇ. ئەگەر ماڭا ئۆزىڭىز ياخرۇرىدىغان ژانرانى دەپبەرسىڭىز سىزگە بىرياخشى ئانىمې تەۋسىيە قىلالايمەن. 诸神字幕组 天空数字幕组 لۇغەتخۇجىيىڭ تور مەكتىپىنىڭ توربەت لۇغىتىنى ئىشلەتسىڭىز بولىدۇ، بۇيەرنى چىكىپ زىيارەت قىلىڭ. ئەگەر تور بولمىسىمۇ ئىشلەتكىلى بولىدىغان لۇغەت بولسىكە دىسىڭىز ئەپ بازىرىدىن ئىزدەپ بېقىڭ ۋەياكى توۋەندە ئېلخەت ئادىرسىڭىزنى قالدۇرۇپ ئەسكەرىتسىڭىز مەن ئۆزەم ئىشلىتىدىغان ئاددى بىر لۇغەتنى ئەۋەتىپ بەرسەممۇ بولىدۇ، تورلۇغىتىدەك مول بولمىسىمۇ خېلى قولايلىق. مەشىق سوئالみんなの日本語 نىڭ ئىچىدىكى مەشىقلەر ناھايىتى ياخشى، شۇنى ئىشلەپ تولۇق چۇشىنىۋالسىڭىز بولىدۇ. سۆزلەشみんなの日本語 نىڭ ئىچىدىكى دىئالوگنى ئاۋازىڭىزنى چىقىرىپ ئوقۇپ يادىلىسىڭىز بەك ياخشى. ئاندىن بىرە فىلىم كۆگەندىمۇ شۇلانى دوراپ سۆزلىسىڭىزمۇ بولىدۇ. ئەگەر سىز ئالى-مەكتەپ ئوقۇغۇچىسى بولسىڭىز، مەكتىپىڭىزدىكى مەنبەلەردىن ياخشى پايدىلىنىڭ، ئادەتتە ياپونتىلى كەسپى بارلا مەكتەپ بولسا، بىر نەچچە نەپەر ياپونلۇق مۇئەللىم ئېنىقلام بار. شۇلانى ئىزدەپ چۈشەندۇرۈپ پاراڭلىشىڭ، ھەتتا دەرىسىگىمۇ قاتنىشالايسىز. بەكلام پادىسى بولىدۇ، ياپونلۇق مۇئەللىممۇ سىزنى ئۆز ئۇقۇغۇچىسىدەك كۆرۈپ ياردەم قىلىشى،مۇڭدىشىشى مۇمكىن. مەنمۇ ئەينى ۋاقىتتا شۇندا قىلىپ ياپونتىلى كەسپىنىڭ 3، 4 چى يىللىقتىكىلەرنىڭ دەرىسىنى ئېلىۋالغان ئىدىم.ئىشقىپ مەنبەنى ياخشى قەدىرلەڭ! دۆلەت ئىچىدە ئوقۇشقا كېتىدىغان خىراجەت بەكلام ئەرزان، ئامرىكىدەك يەرگە كەلسىڭىز، دەرىسلىك كىتابنىمۇ ئېلىشقا قۇربىڭىز يەتمەسلىكى ناھايىتى نورمال ئىش، بىر دەرىسلىك كىتاب قىممەت بولغاندا ھەتتا دولەتتىكى ئالى-مەكتەپنىڭ بىر يىللىق ئوقۇش پۇلىغىمۇ تەڭ بولالايدۇ. راس گەپ! 800 دوللارلىق كىتابنى كۆرەپ، بۇرۇن بىلىمنىڭ قانچىلىك ئەرزانچىلىق يەردە تۇرغانلىقىنى ھېس قىلغان ئدىم.😅 نىشان ۋە پىلانتىلنى ئۆگىنىپ ۋايىغا يەتكۈمىگىچە قەرەرلىك ئۆگۈنۈپ تەكرارلاپ تۇرمىسا ئادەم ئاسانلا ئۇنتۇيدۇ. شۇقا بۇ مۇساپىنى بېسىپ چىقىش ئۈچۈن، نىشاننى بېكىتىپ قەرەرلىك ئۆگۈنۇپ تۇرشىڭىز كېرەك. مەسىلەن توۋەندىكىدەك پىلان تۈزۇپ، ئۆزىڭىز بىكىتكەن ۋاقىتتا ئورۇنلاپ ماڭسىڭىز ناھايىتى ياخشى. مەسىلەن قىسقا مۇددەتلىك نىشاننى بىر ھەپتىدە، ئوتتۇرا مۇددەتلىكنى بىر ئايدا، ئۇزۇن مۇددەتلىك پىلاننى بىر يىلدا ئورۇنلاپ چىقىش دىگەندەك. ئەمدى ۋاقىت ئارلىقىنى ئۆزىڭىزنىڭ ئەھۋالىغا قاۋاپ بېكىتىڭ، قەرەرلىك داۋاملشتۇرۇش ئەڭ مۇھىم. قىسقا مۇددەتلىك نىشان ياپونتىلى ئۆگىنىش كىتابىدىن بىر دەرىس ئۆگىنىش 100 تال يېڭى سۆزلۈك ئوگىنىش ئوقۇلما: بىر ئادىراق ياشلار مانگاسىنى ئوقۇش. (ياپۇننىڭ چاتما رەسىملىك كارتون كىتابلىرى، 少年漫画). فىلىم: تەكتىدە ياپونچە خىتى بار ئانىمېدىن 5 قىسىم كۆرۇش ياكى ياپوننىڭ تېلۋىزىيە تىياتېرلىرىنى كۆرسىڭىزمۇ بولىدۇ، ھەم ياختۇرغان جۇملە سۆزلەرنى كۆرەپ بولۇپ خاتىرلىۋېلىش. ئوتتۇرا مۇددەتلىك نىشان بىر دەرىسلىك كىتابنى تۈگىتىش بىر روماننى ئوقۇپ تۈگىتىش بۇرۇن ئوقۇغان مانگانى قايتا ئوقۇپ چىقىش 3000 سۆزلۈك ئۆگىنىش بىر بۆلۇم تەكتىدە ياپونچە خىتى يوق ئانىمې كۈرۈش ئۇزۇن مۇددەتلىك نىشان تەكتىدە خېتى يوق ياكى پەقەتلا ياپونچە خېتى بار ئانىمېنى كورۈپ چۇشىنىش. مانگا ياكى روماننى ئوقۇپ چۈشىنىش ياپونتىلىنى تەرجىمە قىلالاش ياپونچە پاراڭلىشالاش. ئاخىرىدائەگەر ياپونتىلىغا ئائىت بىرە سوئاللا بولسا، ئىنكاس رايونىدا خەت قالدۇرۇپ سورىسىڭىز بولىدۇ.😀","categories":[{"name":"Language","slug":"Language","permalink":"https://shohret.github.io/categories/Language/"},{"name":"Japanese","slug":"Language/Japanese","permalink":"https://shohret.github.io/categories/Language/Japanese/"}],"tags":[{"name":"Japanese","slug":"Japanese","permalink":"https://shohret.github.io/tags/Japanese/"},{"name":"Uyghur","slug":"Uyghur","permalink":"https://shohret.github.io/tags/Uyghur/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-14T04:23:38.000Z","updated":"2017-07-23T03:45:08.000Z","comments":true,"path":"2017/03/13/hello-world/","link":"","permalink":"https://shohret.github.io/2017/03/13/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[يىللارغا جاۋاپ]]></title>
    <url>%2F2018%2F04%2F15%2FYillargha-Jawap%2F</url>
    <content type="text"><![CDATA[ﻟﯘﺗﭙﯘﻟﻼ ﻣﯘﺗﻪﻟﻠﯩﭗ ۋاقىت ئالدىراڭغۇ ساقلاپ تۇرمايدۇ، يىللار ۋاقىتنىڭ ئەڭ چوڭ يورغىسى. ئاققان سۇلار، ئاتقان تاڭلار قايتىلانمايدۇ، يورغا يىللار ئۆمۈرنىڭ يامان ئوغرىسى. ئوغرىلاپلا قاچىدۇ ئارقىغا يانماي، بىر-بىرىنى قوغلىشىپ، يورغىلىشىپ. ياشلىق بېغىدا بۇلبۇللار قانات قاقماي، يوپۇرماقلار قۇيۇلىدۇ پورلىشىپ. ياشلىق ئادەمنىڭ زىلۋا بىر چېغى، تولىمۇ قىسقا ئۇنىڭ ئۆمرى بىراق، يىرتىلسا كالىندارنىڭ بىر ۋارىقى، ياشلىق گۈلىدىن تۆكۈلىدۇ بىر تال يۇپۇرماق. يىللار شامىلى يەلپۈنىدۇ، ئىزلار كۆمۈلىدۇ، يوپۇرماقسىز دەرەخ بىچارە-بولىدۇ قاخشال. يىللار سېخى قۇرۇق كەلمەيدۇ ئەكىلىپ بېرىدۇ، قىزلارغا قورۇق، ئەرلەرگە ساقال. بىراق يىللارنى تىللاش توغرا كەلمەيدۇ، مەيلى ئۆتىۋەرسۇن، ئۆزىنىڭ يولى. ئادەملەرمۇ ۋاقىتنى قولدىن بەرمەيدۇ، چۆللەرنى بوستان قىلغان ئادەملەر قولى. يىللارنىڭ قوينى كەڭ، پۇرسىتى نۇرغۇن، تاغدەك ئىشلار يىللار بىلەن ئۆرە تۇرىدۇ. قاراب باق ئاخشامقى بوۋاق كىچىككىنە تۇرسۇن، تۈنۈگۈن ئۆمىلەپ، ھە… بۈگۈن مېڭىپ يۈرىدۇ. كۆرەشچان بالىلار قوغلىشىپ يىللار، كۆرەش نەۋرىلىرىنى چوقۇم تاپىدۇ. ئاخشام بەخىت ئۈچۈن قۇربان بولغانلار، قەبرىسىنى يادلاپ گۈللەر ياپىدۇ. مەيلى ساقال سوۋغا قىلسا قىلسۇن يىللار، مەنمۇ تاۋلىنىمەن يىللار قوينىدا. ئىجادىم شېئىرىمنىڭ ئىز تامغىسى بار، ئالدىمدىن قېچىپ ئۆتكەن ھەر يىل بوينىدا قېرىماسمەن كۆرەشنىڭ كەسكىن چېغىدا، شېئىرىم يۇلتۇز بولۇپ يانار ئالدىمدا. ئۆلۈم پەستە قېلىش كۆرەشنىڭ داۋانلىق تېغىدا، چىدام غەيرەتنىڭ يەڭگىنى ھەريان يادىمدا. ئېسىلارمەن مىلتىق ئېتىپ تاۋلانغان قولغا، يېپىشارمەن بايراق بىلەن ئالغا ئاتلىغان يولغا. كۈرەش باياۋانىدا ھارماسمەن ئەسلا، كۈرەش بىلەن كىلىپ چىقىمىز كەڭ غالىب يولغا. يىللار مەيدەڭنى تۇتۇپ قاقاقلاپ كۈلمە، ئالدىڭدا قىزىرىشتىن ئارتۇق كۆرىمەن ئۆلۈمنى. قېرىتىمەن دەپ ئارتۇق كۆڭۈل بۆلمە، ئاخىرقى جەڭگە ئاتاپ قۇيارمەن ئوغلۇمنى. يىللار دېڭىزى دولقۇنلۇق بولساڭمۇ، ئۇپقۇنلىرىڭنى يارىدۇ بىزنىڭ كاراپ. يىلنىڭ ئۆتۈشى بىلەن قورقىتىپ باقساڭمۇ، ئىجاد يىللارنى قېرىتىدۇ دەپ بېرىمىز جاۋاب.]]></content>
      <categories>
        <category>Language &amp; Literature</category>
        <category>Uyghur</category>
      </categories>
      <tags>
        <tag>Uyghur</tag>
        <tag>poem</tag>
        <tag>ﻟﯘﺗﭙﯘﻟﻼ ﻣﯘﺗﻪﻟﻠﯩﭗ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFS & DFS]]></title>
    <url>%2F2018%2F04%2F13%2FBFS-and-DFS%2F</url>
    <content type="text"><![CDATA[Breadth-first Search Running time complexity: O(V + E) Memory complexity is not good as we have to sort lots of references. That is why DFS is usually preferred. But it constructs a shortest path: Dijkstra algorithm does a BFS if all the edge weights are equal to one. We have an empty queue at the beginning and we keep checking whether we have visited the given node or not. Keep iterating until queue is not empty. Applications In artificial intelligence / machine learning it can prove to be very important, robot can discover the surrounding more easily with BFS than DFS. It is also important in maximum flow, Edmonds-Karp algorithm uses BFS for finding augmenting paths. Serialization / deserialization of a tree like structure, when order does matter, it allows the tree to be reconstructed in an efficient manner. 12345678910111213141516171819202122232425262728293031323334353637383940414243class Node(object): def __init__(self, name): self.name = name self.adjacencyList = [] self.visited = False self.prodecessor = Noneclass BreadthFirstSearch(object): def bfs(self, startNode): queue = [] queue.append(startNode) startNode.visited = True # BFS --&gt; queue # DFS --&gt; stack BUT usually implement it with recursion while queue: actualNode = queue.pop(0) print(actualNode.name) for n in actualNode.adjacencyList: if not n.visited: n.visited = True queue.append(n)node1 = Node('A')node2 = Node('B')node3 = Node('C')node4 = Node('D')node5 = Node('E')node1.adjacencyList.append(node2)node1.adjacencyList.append(node3)node1.adjacencyList.append(node4)node1.adjacencyList.append(node5)bfs = BreadthFirstSearch()bfs.bfs(node1) Depth-first Search Depth-first search is a widely used graph traversal algorithm besides breadth-first search. It explores as far as possible along each branch before backtracking. Time complexity: O(V + E) Memory complexity: slightly better than BFS 123456789101112131415161718192021222324252627282930313233343536class Node(object): def __init__(self, name): self.name = name self.adjacencyList = [] self.visited = False self.predecessor = None# DFS --&gt; stack(os level) goes as deep as possible# BFS --&gt; queue, layer by layerclass DepthFirstSearch(object): def dfs(self, node): node.visited = True print(node.name) for n in node.adjacencyList: if not n.visited: self.dfs(n)node1 = Node('A')node2 = Node('B')node3 = Node('C')node4 = Node('D')node5 = Node('E')node1.adjacencyList.append(node2)node1.adjacencyList.append(node3)node1.adjacencyList.append(node4)node1.adjacencyList.append(node5)dfs = DepthFirstSearch()dfs.dfs(node1) GeeksforGeeksBreadth First Search or BFS for a GraphDepth First Search or DFS for a GraphBFS vs DFS for Binary TreeAlgorithm Questions]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>graph traversal</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Basic Sorting Algorithms]]></title>
    <url>%2F2018%2F03%2F09%2FBasic-Sorting-Algorithms%2F</url>
    <content type="text"><![CDATA[Some FeaturesTime ComplexityTypical ones are: O(n^2) or O(nlogn) or O(n), for more check Big-O Cheatsheet.In-placeStrictly an in-place sort needs only o(1) memory beyond the items being sorted.So an in place algorithm does not need any extra memory.RecursiveSome sorting algorithms are implemented in a recursive manner, especially the divide and conquer ones. Such as merge sort and quick sort.StableStable sorting algorithms maintain the relative order of records with equal values. Bubble Sort Repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order It is too slow and impractical for most problems even when compared to insertion sort Bubble sort has worst-case and average complexity both O(n*n) Bubble sort is not a practical sorting algorithm It will not be efficient in the case of a reverse-ordered collection In computer graphics it is popular for its capability to detect a very small error (like swapping of only two elements) in almost-sorted arrays and fix it with just linear complexity 1234567891011121314151617181920212223242526# Bubble Sort# O(n^2) running time# in-place sorting algorithm, no need extra memorydef bubble_sort(nums): for i in range(len(nums)): for j in range(0, len(nums) - i - 1): if nums[j] &gt; nums[j + 1]: swap(nums, j, j + 1) return numsdef swap(nums, i, j): temp = nums[i] nums[i] = nums[j] nums[j] = tempif __name__ == "__main__": a = [1, 5, 3, 2, 4, 8, 7] b = [4, 3, 2, 1] print(bubble_sort(a)) print(bubble_sort(b)) Bubble Sort - GeeksforGeeks Selection Sort O(n^2) running time complexity Selection sort is noted for its simplicity, and it has performance advantages over more complicated algorithms Particularly useful where auxiliary memory is limited The Algorithm divides the input list into two parts: the subarray of items already sorted and the subarray of items remaining to be sorted that occupy the rest of the array It is an in-place algorithm, no need for extra memory Selection sort almost always outperform bubble sort Not a stable sort, does not preserve the order of keys with equal values Quite counter-intuitive: selection sort and insertion sort are both typically faster for small arrays Make less writes than insertion sort, this can be important if writes are significantly more expensive than reads, for example with EEPROM or flash memory where every writes lessens the lifespan of the memory 12345678910111213141516171819202122232425262728293031# Selection Sort# O(n^2) running time# in-place sorting algorithm, no need extra memorydef selection_sort(nums): for i in range(len(nums)): min_idx = i for j in range(i + 1, len(nums)): if nums[j] &lt; nums[min_idx]: min_idx = j if min_idx != i: swap(nums, min_idx, i) return numsdef swap(nums, i, j): temp = nums[i] nums[i] = nums[j] nums[j] = tempif __name__ == "__main__": a = [4, 3, 2, 1] b = [5, 2, 1, 7, 6, 7, 8, 0] print(selection_sort(a)) print(selection_sort(b)) Selection Sort - GeeksforGeeks Insertion Sort O(n^2) time complexity. It is a simple sorting algorithm that builds the final array one item at a time On large datasets it is very inefficient but on arrays with 10 to 20 items it is good Simple implementation, it is more efficient than other quadratic running time sorting procedures such as bubble sort and selection sort Adaptive algorithm, speed up when array is already substantially sorted Stable sort, preserve the order of the items with equal keys In-place algorithm, does not need any extra memory It is an online algorithm, it can sort an array as it receives it for example downloading data from web Hybrid algorithms uses insertion sort if the subarray is small enough Variant of insertion sort is shell sort Insertion sort requires more writes because the inner loop can require shifting large sections of the sorted portion of the array In general, insertion will write to the array O(n^2) times while selection sort will write only O(n) times. For this reason selection sort maybe preferable in cases where writing to memory is significantly more expensive than reading, such as flash memory 123456789101112131415161718192021222324252627# Insertion Sort# running time O(n^2)# in-place algorithm, variant of insertion sort is shell sortdef insertion_sort(nums): for i in range(len(nums)): j = i while j &gt; 0 and nums[j - 1] &gt; nums[j]: swap(nums, j, j - 1) j = j - 1 return numsdef swap(nums, i, j): temp = nums[i] nums[i] = nums[j] nums[j] = tempif __name__ == "__main__": a = [4, 3, 5, 6, 7, 2, 1] print(insertion_sort(a)) Insertion Sort - GeeksforGeeks QuickSort It is an efficient sorting algorithm A well implemented quickSort can outperform heap sort and merge sort -&gt; the main competitors of quickSort A comparison based algorithm, not able to be faster than linear time complexity The efficient implementation of quickSort is not stable, does not keep the relative order of items with equal value It is in-place, does not need any additional memory On average case it has O(nlogn) running time But the worst case running time is quadratic o(n^2) It is widely used in programming languages Primitive types -&gt; usually quickSort is used Reference types / objects -&gt; usually merge sort is used It is divide and conquer algorithm pick an element from the array as pivot item partition phase: rearrange the array so that all elements with values less than the pivot, while all elements with values greater than the pivot come after it // equal values can go either way recursively apply these steps on the subarray base case for recursion: arrays of size zero or one never need to be sorted Choosing the pivot item It is very important, if we keep choosing bad pivots, the running time will be quadratic. Option 1: we can choose a pivot at random // usually it works Option 2: choosing the middle index of the array as the pivot 123456789101112131415161718192021222324252627282930313233343536373839# QuickSort# in-place algorithm, O(NlogN)def quick_sort(nums, low, high): if low &gt;= high: return pivot_index = partition(nums, low, high) quick_sort(nums, low, pivot_index - 1) quick_sort(nums, pivot_index + 1, high) return numsdef partition(nums, low, high): pivot_index = (low + high) // 2 swap(nums, pivot_index, high) i = low for j in range(low, high): if nums[j] &lt;= nums[high]: swap(nums, i, j) i += 1 swap(nums, i, high) return idef swap(nums, i, j): temp = nums[i] nums[i] = nums[j] nums[j] = tempif __name__ == "__main__": a = [4, 2, 5, 7, 1, -7, -3, 9] print(quick_sort(a, 0, len(a) - 1)) QuickSort - GeeksforGeeks Merge Sort Merge sort is a divide and conquer, stable, and comparison based algorithm Merge sort is not a in-place algorithm Efficient quickSort implementations generally outperform merge sort Merge sort is often the best choice for sorting a linked list: in this situation it is relatively easy to implement a merge sort in such a way that it requires only O(1) extra space Process: divide the array into two subarrays recursively sort these subarrays recursively with merge sort again if there is only a single item left in the subarray -&gt; we consider it to be sorted by definition merge the subarrays to get the final sorted array 123456789101112131415161718192021222324252627282930313233343536373839404142434445# Merge Sort# not an in-place algorithm, O(NlogN)def merge_sort(nums): if len(nums) == 1: return mid_index = len(nums) // 2 left_half = nums[:mid_index] right_half = nums[mid_index:] # divide merge_sort(left_half) merge_sort(right_half) # conquer i, j, k = 0, 0, 0 while i &lt; len(left_half) and j &lt; len(right_half): if left_half[i] &lt; right_half[j]: nums[k] = left_half[i] i += 1 else: nums[k] = right_half[j] j += 1 k += 1 while i &lt; len(left_half): nums[k] = left_half[i] i += 1 k += 1 while j &lt; len(right_half): nums[k] = right_half[j] j += 1 k += 1 return numsif __name__ == "__main__": a = [1, 2, 4, 3, -7, -3] print(merge_sort(a)) Merge Sort - GeeksforGeeks Hybrid SortIntroSort Also known as introspective sort It is a hybrid sorting algorithm that provides both fast average performance and optimal worst-case performance It begins with quickSort and switches to heapSort when quickSort becomes slow IntroSort = quickSort + heapSort Timsort Timsort = merge sort + insertion sort It is a stable sorting algorithm It was implemented by Tim Peters in 2002 for use in the Python programming languge Best case running time: O(n) Worst case running time: O(nlogn) Worst case space complexity: O(n)]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>Python</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Heap Implementation]]></title>
    <url>%2F2018%2F02%2F27%2FHeap-Implementation%2F</url>
    <content type="text"><![CDATA[Priority Queue It is an abstract data type such as stack or queue But every item has an additional property: a priority value Priority Queue is usually implemented with heaps, but it can be implemented with self balancing trees as well The highest priority element is retrieved first, no FIFO structure here Operation: InsertWithPriority(data, priority), getHighestPriorityElement(), peek() Heap It is basically a binary tree Two main binary heap types: min and max heap In a max heap, the keys of parent nodes are always greater than or equal to those of the children, the highest key is in the root node It cannot be unbalanced! We insert every new item to the next available place Application: Dijkstra algorithm, Prims algorithm Heap Sort Comparison-based algorithm Use heap data structure rather than a linear-time search to find the maximum Generally a little bit slower than quick sort, it has the advantage of a more favorable worst-case O(nlogn) runtime Does NOT need additional memory First we have to construct the heap itself from the numbers we want to sort -&gt; O(n) Operation Time Complexity Find min/max O(1) Remove min/max O(log(n)) Insert O(log(n)) Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class Heap(object): HEAP_SIZE = 10 def __init__(self): self.heap = [0] * Heap.HEAP_SIZE self.currentPosition = -1 def insert(self, item): if self.isFull(): print('Heap is full...') return self.currentPosition = self.currentPosition + 1 self.heap[self.currentPosition] = item self.fixUp(self.currentPosition) def fixUp(self, index): parentIndex = int((index - 1) / 2) while parentIndex &gt;= 0 and self.heap[parentIndex] &lt; self.heap[index]: temp = self.heap[index] self.heap[index] = self.heap[parentIndex] self.heap[parentIndex] = temp parentIndex = int((index - 1) / 2) def heapsort(self): for i in range(self.currentPosition + 1): temp = self.heap[0] print(temp) self.heap[0] = self.heap[self.currentPosition - i] self.heap[self.currentPosition] = temp self.fixDown(0, self.currentPosition - i - 1) def fixDown(self, index, upto): while index &lt;= upto: leftChild = 2 * index + 1 rightChild = 2 * index + 2 if leftChild &lt; upto: childToSwap = None if rightChild &gt; upto: childToSwap = leftChild else: if self.heap[leftChild] &gt; self.heap[rightChild]: childToSwap = leftChild else: childToSwap = rightChild if self.heap[index] &lt; self.heap[childToSwap]: temp = self.heap[index] self.heap[index] = self.heap[childToSwap] self.heap[childToSwap] = temp else: break index = childToSwap else: break def isFull(self): if self.currentPosition == heap.HEAP_SIZE: return True else: return Falseif __name__ == '__main__': heap = Heap() heap.insert(10) heap.insert(-20) heap.insert(0) heap.insert(2) heap.heapsort() 123456789101112131415# heap in Pythonfrom heapq import heappop, heappush, heapifyheap = []nums = [12, 3, -2, 6, 4, 8, 9]# for num in nums:# heappush(heap, num)# while heap:# print(heappop(heap))heapify(nums)print(nums) # &gt;&gt;&gt; [-2, 3, 8, 6, 4, 12, 9]]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>data structure</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trees Implementation]]></title>
    <url>%2F2018%2F02%2F01%2FTrees-Implementation%2F</url>
    <content type="text"><![CDATA[Binary Search Tree Average Case Worst Case Space O(n) O(n) Insert O(log(n)) O(n) Delete O(log(n)) O(n) Search O(log(n)) O(n) Trees Traversal: In-order Traversal: left -&gt; root -&gt; right Pre-order Traversal: root -&gt; left -&gt; right Post-order Traversal: left -&gt; right -&gt; root 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129class Node(object): def __init__(self, data): self.data = data self.leftChild = None self.rightChild = Noneclass BinarySearchTree(object): def __init__(self): self.root = None def insert(self, data): if not self.root: self.root = Node(data) else: self.insertNode(data, self.root) # O(logn) if the tree is balanced. If it is not, it can be reduced to O(n) def insertNode(self, data, node): if data &lt; node.data: if node.leftChild: self.insertNode(data, node.leftChild) else: node.leftChild = Node(data) else: if node.rightChild: self.insertNode(data, node.rightChild) else: node.rightChild = Node(data) def remove(self, data): if self.root: self.root = self.removeNode(data, self.root) def removeNode(self, data, node): if not node: return node if data &lt; node.data: node.leftChild = self.removeNode(data, node.leftChild) elif data &gt; node.data: node.rightChild = self.removeNode(data, node.rightChild) else: if not node.leftChild and not node.rightChild: print('Removing a leaf node') del node return None elif not node.leftChild: print('Removing a node with single right child...') tempNode = node.rightChild del node return tempNode elif not node.rightChild: print('Removing a node with single left child...') tempNode = node.leftChild del node return tempNode print('Removing node with two children...') tempNode = self.getProdecessor(node.leftChild) node.data = tempNode.data node.leftChild = self.removeNode(tempNode.data, node.leftChild) return node def getProdecessor(self, node): if node.rightChild: return self.getProdecessor(node.rightChild) return node def getMinValue(self): if self.root: return self.getMin(self.root) def getMin(self, node): if node.leftChild: return self.getMin(node.leftChild) return node.data def getMaxValue(self): if self.root: return self.getMax(self.root) def getMax(self, node): if node.rightChild: return self.getMax(node.rightChild) return node.data def traverse(self): if self.root: self.traverseInOrder(self.root) def traverseInOrder(self, node): if node.leftChild: self.traverseInOrder(node.leftChild) print(node.data) if node.rightChild: self.traverseInOrder(node.rightChild)bst = BinarySearchTree()bst.insert('a')bst.insert('s')bst.insert('b')bst.insert('t')# print(bst.getMaxValue())# print(bst.getMinValue())# bst.remove('s')bst.remove('a')bst.traverse() AVL TreeAVL trees and red-black trees are guaranteed to be balanced, so O(log(n)) is guaranteed. Average Case Worst Case Space O(n) O(n) Insert O(log(n)) O(log(n)) Delete O(log(n)) O(log(n)) Search O(log(n)) O(log(n)) Applications Databases when deletion or insertion are not so frequent, but have to make a lot of look-ups. Red-Black trees are a little bit more popular, as for AVL we have to make several rotations, a little bit slower. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191class Node(object): def __init__(self, data): self.data = data self.height = 0 self.leftChild = None self.rightChild = Noneclass AVL(object): def __init__(self): self.root = None def insert(self, data): self.root = self.insertNode(data, self.root) def insertNode(self, data, node): if not node: return Node(data) if data &lt; node.data: node.leftChild = self.insertNode(data, node.leftChild) else: node.rightChild = self.insertNode(data, node.rightChild) node.height = max(self.calcHeight(node.leftChild), self.calcHeight(node.rightChild)) + 1 return self.settleViolation(data, node) def settleViolation(self, data, node): # four different cases balance = self.calcBalance(node) if balance &gt; 1 and data &lt; node.leftChild.data: print('Left Left heavy situation...') return self.rotateRight(node) elif balance &lt; - 1 and data &gt; node.rightChild.data: print('Right right heavy situation...') return self.rotateLeft(node) # left and right rotation elif balance &gt; 1 and data &gt; node.leftChild.data: print('Left right heavy situation...') node.leftChild = self.rotateLeft(node.leftChild) return self.rotateRight(node) # right and left rotation elif balance &lt; -1 and data &lt; node.rightChild.data: print('Right left heavy situation...') node.rightChild = self.rotateRight(node.rightChild) return self.rotateLeft(node) return node def calcHeight(self, node): if not node: return -1 return node.height # if it returns value &gt; 1, it means it is a left heavy tree --&gt; right rotation # if it returns value &lt; -1, it means it is a right heavy tree --&gt; left rotation def calcBalance(self, node): if not node: return 0 return self.calcHeight(node.leftChild) - self.calcHeight(node.rightChild) def traverse(self): if self.root: self.traverseInOrder(self.root) def traverseInOrder(self, node): if node.leftChild: self.traverseInOrder(node.leftChild) print(node.data) if node.rightChild: self.traverseInOrder(node.rightChild) def rotateRight(self, node): print('Rotating to the right on node', node.data) temLeftChild = node.leftChild t = temLeftChild.rightChild temLeftChild.rightChild = node node.leftChild = t node.height = max(self.calcHeight(node.leftChild), self.calcHeight(node.rightChild)) + 1 temLeftChild.height = max(self.calcHeight(temLeftChild.leftChild), self.calcHeight(temLeftChild.rightChild)) + 1 return temLeftChild def rotateLeft(self, node): print('Rotating to the left on node', node.data) temRightChild = node.rightChild t = temRightChild.leftChild temRightChild.leftChild = node node.rightChild = t node.height = max(self.calcHeight(node.leftChild), self.calcHeight(node.rightChild)) + 1 temRightChild.height = max(self.calcHeight(temRightChild.leftChild), self.calcHeight(temRightChild.rightChild)) + 1 return temRightChild def remove(self, data): if self.root: self.root = self.removeNode(data, self.root) def removeNode(self, data, node): if not node: return node elif data &lt; node.data: node.leftChild = self.removeNode(data, node.leftChild) elif data &gt; node.data: node.rightChild = self.removeNode(data, node.rightChild) else: if not node.leftChild and not node.rightChild: print('Removing a leaf node') del node return None elif not node.leftChild: print('Removing a node with right child...') tempNode = node.rightChild del node return tempNode elif not node.rightChild: print('Removing a node with left child...') tempNode = node.leftChild del node return tempNode print('Removing node with two children...') tempNode = self.getProdecessor(node.leftChild) node.data = tempNode.data node.leftChild = self.removeNode(tempNode.data, node.leftChild) if not node: return node # if the tree has only a single node node.height = max(self.calcHeight(node.leftChild), self.calcHeight(node.rightChild)) + 1 balance = self.calcBalance(node) # doubly left heavy situation if balance &gt; 1 and self.calcBalance(node.leftChild) &gt;= 0: return self.rotateRight(node) # doubly right heavy situation elif balance &lt; -1 and self.calcBalance(node.rightChild) &lt;= 0: return self.rotateLeft(node) # left right case elif balance &gt; 1 and self.calcBalance(node.leftChild) &lt;= 0: node.leftChild = self.rotateLeft(node.leftChild) return self.rotateRight(node) # right left case elif balance &lt; -1 and self.calcBalance(node.rightChild) &gt; 0: node.rightChild = self.rotateRight(node.rightChild) return self.rotateLeft(node) return nodeavl = AVL()avl.insert(10)avl.insert(20)avl.insert(5)avl.insert(4)avl.insert(15)avl.remove(5)avl.remove(4)avl.traverse() Red-Black Tree Average Case Worst Case Space O(n) O(n) Insert O(log(n)) O(log(n)) Delete O(log(n)) O(log(n)) Search O(log(n)) O(log(n)) Red-Black tree properties: Each node is either red or black The root node is always black Every red most have two black child nodes and no other children -&gt; it must have a black parent Every path from a given node to any of its descendant Null nodes contains the same number of black nodes. Tries &amp; Ternary Search TreeHash Table VS Tries We can replace hash tables with tries, tries are more efficient for search misses Hash table the key is going to be converted into an index with the help of the hash function Tries, we consider every single character of the key, but we return right when there is a mismatch. For tries there is no collision. Tries can provide string, so alphabetical ordering of the entries by keys. Hash table does not. No hash function needed for tries. Applications Predictive text, auto-complete feature Spell checking 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Node(object): def __init__(self, character): self.character = character self.leftNode = None self.midNode = None self.rightNode = None self.value = 0class TST(object): def __init__(self): self.rootNode = None def put(self, key, value): self.rootNode = self.putItem(self.rootNode, key, value, 0) def putItem(self, node, key, value, index): c = key[index] if node is None: node = Node(c) if c &lt; node.character: node.leftNode = self.putItem(node.leftNode, key, value, index) elif c &gt; node.character: node.rightNode = self.putItem(node.rightNode, key, value, index) elif index &lt; len(key) - 1: node.midNode = self.putItem(node.midNode, key, value, index + 1) else: node.value = value return node def get(self, key): node = self.getItem(self.rootNode, key, 0) if node is None: return -1 # means given key is not present in the dictionary return node.value def getItem(self, node, key, index): if node is None: return None c = key[index] if c &lt; node.character: return self.getItem(node.leftNode, key, index) elif c &gt; node.character: return self.getItem(node.rightNode, key, index) elif index &lt; len(key) - 1: return self.getItem(node.midNode, key, index + 1) else: return nodeif __name__ == "__main__": tst = TST() tst.put('apple', 100) tst.put('orange', 200) print(tst.get('apple'))]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>data structure</tag>
        <tag>AVL</tag>
        <tag>BST</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to Use ~ば]]></title>
    <url>%2F2018%2F01%2F29%2FHow-to-Use-ba-Particle%2F</url>
    <content type="text"><![CDATA[The conditional 〜ば form changes differently in these word types: 『動詞』(verb)、『い形容詞』(i adjective)、『な形容詞』(na adjective)、そして『名詞』(noun)。And 『動詞』(verb) will include three different categories: u verb, ru verb, and exceptions. 動詞う動詞U verb is also called 「五段動詞』. When we change it to ~ば conditional form, we need to change it from u sound to e sound. (う段からえ段へ). And then add a ば at the end. 例：会う あう → あえば歩く あるく → あるけば出す だす → だせば待つ まつ → まてば死ぬ しぬ → しねば飛ぶ とぶ → とべば頼む たのむ → たのめば在る ある → あれば る動詞Ru verb is always easy to change. To change it to 〜ば conditional form, we just need to replace る with れば。 例：入れる いれる → いれれば浴びる あびる → あびれば教える おしえる → おしえれば並べる ならべる → ならべれば 『する』『くる』する → すれば例：勉強する → 勉強すれば くる → くれば い形容詞To convert い adjective to conditional form, we need to remove い, then add ければ at the end. 例：おいしい → おいしければいそがしい → 忙しければおおい → おおければたかい → たかければPlease note, there is one exception in い adjective. When adjective いい changes to conditional form, いい will change to 良い（よい）, then remove い、add ければ.いい → 良ければ よければ な形容詞Let’s put な adjective and noun together, as most of the case な adjective always comes before a noun. And we usually don’t use 〜ば after a な adjective or verb. Instead, we use 『なら』 after a noun.『なら』is also a condition auxiliary, means if; in case;. You can check it more from here. 例：北海道 → 北海道ならＮ１ → Ｎ１ならにぎやか → にぎやかなら簡単 → 簡単なら Negative / 否定To make a negative condition, we just need to change all original forms to the negative ない form, then change ない to なければ. 例：彼だ → 彼じゃない → 彼じゃなければ静かだ → 静かじゃない → 静かじゃなければおいしい → おいしくない → おいしくなければ行く → 行かない → 行かなければ 練習You can try to change following words to conditional form. たいへん たのしい 読む 本屋 小さい いる（存在動詞） 200グラム 寒い 呼ぶ 捨てない 疲れている 出張する 立派 いい 使う Reference:正樹日本語]]></content>
      <categories>
        <category>Language &amp; Literature</category>
        <category>Japanese</category>
      </categories>
      <tags>
        <tag>language</tag>
        <tag>Japanese</tag>
        <tag>grammar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stack & Queue Implementation]]></title>
    <url>%2F2018%2F01%2F16%2FStack-Queue-Implementation%2F</url>
    <content type="text"><![CDATA[Stack and queue abstract data types implementation with Python. Stack LIFO structure Graph algorithm: depth-first search can be implemented with Stack Finding Euler-cycles in a Graph Finding strongly connected components in a graph If we use recursion, the OS will use stacks Most important application of stacks: stack memory it is a special region of the memory (in the RAM) it keeps track of the point to which each active subroutine should return control when it finishes executing store temporary variables created by each function stack memory is limited Heap Memory The heap is a region that is not automatically arranged for you This is a large region of memory, unlike stack memory C: malloc() and calloc() function, with pointers Java: reference types and objects are on the Heap We have to deallocate these memory chunks as it it not managed automatically. If not, memory leak! Slower than stack memory because of pointers stack memory heap memory limited in size no size limit fast access slow access local variables objects space is managed efficiently by CPU memory may be fragmented variables cannot be resized variables can be resized // realloc() Queue FIFO structure It can be implemented with linked lists application: BFS Operational research applications or stochastic models relies heavily on queues ImplementationStack12345678910111213141516171819202122232425262728293031323334353637383940# stack is an abstract data type (interface), LIFO# there are 3 operations: push(), pop(), peek()class Stack: def __init__(self): self.stack = [] def isEmpty(self): return self.stack == [] def push(self, data): self.stack.append(data) def pop(self): data = self.stack[-1] del self.stack[-1] return data def peek(self): return self.stack[-1] def sizeStack(self): return len(self.stack)# teststack = Stack()stack.push(1)stack.push(2)stack.push(3)print(stack.sizeStack())print('popped: ', stack.pop())print(stack.sizeStack())print('peeked: ', stack.peek())print(stack.sizeStack()) Queue1234567891011121314151617181920212223242526272829303132333435363738394041# queue is an abstract data type (interface) FIFO# operations: enqueue(), dequeue(), peek()# e.g: CPU scheduling, IO bufferclass Queue: def __init__(self): self.queue = [] def isEmpty(self): return self.queue == [] def enqueue(self, data): self.queue.append(data) def dequeue(self): data = self.queue[0] del self.queue[0] return data def peek(self): return self.queue[0] def sizeQueue(self): return len(self.queue)# testqueue = Queue()queue.enqueue(1)queue.enqueue(2)queue.enqueue(3)queue.enqueue(4)print('dequeue: ', queue.dequeue())print(queue.sizeQueue())print('peek: ', queue.peek())print(queue.sizeQueue())]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>data structure</tag>
        <tag>queue</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linked Lists Implementation]]></title>
    <url>%2F2018%2F01%2F15%2FLinked-Lists-Python%2F</url>
    <content type="text"><![CDATA[Advantage Linked Lists are dynamic data structures, arrays are not It can allocate the needed memory in runtime Very efficient if we want to manipulate the first elements Can store items with different sizes; an array assumes every element to be exactly the same It is easier for a linked list to grow organically. An array’s size usually need to be known ahead of time or re-created when it needs to grow Disadvantages Waste memory because of the references Nodes in a linked list must be read in order from the beginning as linked lists have sequential access (array items can be reached via indexes in O(1) time) Solution: doubly linked lists -&gt; easier to read, but memory is wasted in allocating space for a back pointer Pros &amp; Cons of an array Pros We can use random access by indexes, O(1) Very fast implementation and use Very fast data structure A good choice when we want to add items over and over again and we want to get items with given indexes Cons Usually, we have to know the size of the array at compile time If it is full we have to create a bigger array and have to copy values one by one. It is not able to store items with different types (Not the case in Python) Linked Lists vs Arrays Linked Lists Arrays search O(n) O(1) via index insert at the start O(1) O(N) insert at the end O(N) O(1) Waste Space O(N) 0 ImplementationLinked List implementation with Python123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class Node(object): def __init__(self, data): self.data = data self.nextNode = Noneclass LinkedList(object): def __init__(self): self.head = None self.size = 0 # O(1) def insertStart(self, data): self.size = self.size + 1 newNode = Node(data) if not self.head: self.head = newNode else: newNode.nextNode = self.head self.head = newNode def remove(self, data): if self.head is None: return self.size = self.size - 1 currentNode = self.head previousNode = None while currentNode.data != data: previousNode = currentNode currentNode = currentNode.nextNode if previousNode is None: self.head = currentNode.nextNode else: previousNode = currentNode.nextNode # O(1) def size1(self): return self.size # O(N) not good !!!!! def seize2(self): actualNode = self.head size = 0 while actualNode is not None: size += 1 actualNode = actualNode.nextNode return size # O(N) def insertEnd(self, data): self.size = self.size + 1 newNode = Node(data) actualNode = self.head while actualNode.nextNode is not None: actualNode = actualNode.nextNode actualNode.nextNode = newNode def traverseList(self): actualNode = self.head while actualNode is not None: print('%d ' % actualNode.data) actualNode = actualNode.nextNode# testlinkedList = LinkedList()linkedList.insertStart(12)linkedList.insertStart(122)linkedList.insertStart(3)linkedList.insertEnd(5)linkedList.traverseList()linkedList.remove(3)linkedList.remove(5)linkedList.remove(122)print(linkedList.size1()) Other Note abstract data types data structures Stack array, linked list Queue array, linked list Priority queue heap Dictionary / hashmap array]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>data structure</tag>
        <tag>array</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Duolingo Turkish Notes 1]]></title>
    <url>%2F2017%2F08%2F31%2FDuolingo-Turkish-Notes-1%2F</url>
    <content type="text"><![CDATA[It is been one week start learning Turkish on duolingo. Since Turkish is originated from my mother tongue, grammar part is easy for me. But still, need to remember some vocabs. To make it easier to review, I wanted to make a note here. BasicVocabelma: applesu: waterbir: a / anekmek: breadyemek: eatve: andiçmek: drinkveya: orkız: girlerkek: man (gender)adam: mankadın: woman (gender)süt: milksandviç: sandwich Grammarpronouns Singular Plural 1st Person Ben Biz 2nd Person Sen Siz 3rd Person O Onlar Common PhrasesVocabteşekkürler: thank youmerhaba: hellomemnun oldum: nice to meet youhoşçakal: byeiyi akşamlar: good eveninghayır: nogörüşürüz: nice to meet youiyi geceler: good nightevet: yesiyi şanslar: good luckaffedersin: execuse me:günaydın: good morninggüle güle: goodbyerica ederim: you’re welcomebiliyorum: I knowtürkçe: Turkishingilizce: Englishlütfen: pleasebilmiyorum: I don’t knowselam: Hihoş geldin: welcomehoş geldiniz: welcome (formal way)iyiyim: I am goodnasılsın: how are you?nasılsınız: how are you (formal way)tamam: alright Adjectives 1Vocabsıcak: hotsoğuk: coldçok: verygenç: younggüzel: beautifulyaşlı: old, eldereski: oldbu: thisşu: thatbunlar: theseşunlar: thosezor: difficultkolay: easybüyük: bigküçük: small, little FoodVocabkahve: coffeeportakal: orange (noun)makarna: pastayumurta: eggşeker: sugarpasta: cakeçilek: strawberrypeynir:cheesebalık: fishmeyve: fruitçay: teaet: meat, beefyağ: oillimon: lemonçorba: soupdomates: tomatosbira: beertavuk: chickenşarap: winetuz: salt AccusativeVocabmenü: menukolay gelsin: good luck / may it be easyGrammar Turkish English Ben gazete okurum. I read newspapers. or I read a newspaper. Ben gazeteyi okurum. I read the newspaper. Ben bir gazete okurum. I read a newspaper. Vowel Harmony Turkish Accusative Suffix ö, ü -(y)ü o,u -(y)u e,i -(y)i a,ı -(y)ı If the noun ends in a vowel, you have to insert the buffer letter y. Here are some examples: Turkish, Nominative Turkish, Accusative English elma elmayı apple gazete gazeteyi newspaper süt sütü milk limon limonu lemon Consonant Mutations Turkish, Nominative Turkish, Accusative English kitap kitabı book ağaç ağacı tree köpek köpeği dog This means:p → bt → dk → ğç → c AnimalsVocabköpek: dogkedi: catkuş: birdkaplumbağa: turtlekurbağa: frogkuzu: lambkoyun: sheepörümcek: spiderayı: bearfil: elephantfare: mouseaslan: lionhindi: turkeytavşan: rabbitbaykuş: owlördek: duckyengeç: crabat: horseinek: cow PluralGrammarForming the plural in Turkish is simple compared to the Accusative case. It is formed using the suffix -lAr. Now you might be thinking, “what is that capital A doing there?” to which we respond with 2-way vowel harmony. This is the other form of vowel harmony found in Turkey suffixes. Basically if the final vowel is front (i, e, ü, ö) use -ler. If it is back (a, ı, o, u), use the suffix -lar. This rule along with the rule for 4-way vowel harmony will be used in several suffixes across Turkish Grammar, so try to get used to it now. Turkish, Nominative English Turkish, Plural English ayı bear ayılar bears kuş bird kuşlar birds kurbağa frog kurbağalar frogs köpek dog köpekler dogs hindi turkey hindiler turkeys menü menu menüler menus To beCopula Suffix Person/Number Example English -(y)Im 1st sing. (Ben) mutluyum. I am happy. -sIn 2nd sing. (Sen) mutlusun. You are happy. ∅, -DIr 3rd sing O mutlu. He/She/It is happy. -(y)Iz 1st pl. (Biz) mutluyuz. We are happy. -sInIz 2nd pl. (Siz) mutlusunuz. You are happy. ∅, -DIr 3rd pl. Onlar mutlu/mutludur. They are happy. -lAr, -DIrlAr 3rd pl. (Onlar) mutlular/mutludurlar. They are happy. There are a few points to talk about in the above chart. All except the 3rd person pl. suffix follow 4-way vowel harmony. In the 1st person, you will see a buffer “-y-” be used if the adjective or noun ends in a vowel. The suffix -DIr is used to clarify any ambiguity, emphasize, or state facts. This both follows 4-way vowel harmony and has consonant harmony; ‘d’ changes to ‘t’ after the following consonants (p ç t k s ş h f). The suffix -lAr is optional in the 3rd person pl. However, it is only optional when referring to people. This suffix may not be used for items and animals. Only humans!]]></content>
      <categories>
        <category>Language &amp; Literature</category>
        <category>Turkish</category>
      </categories>
      <tags>
        <tag>duolingo</tag>
        <tag>language</tag>
        <tag>Turkish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drawing and Song - Tokyo Ghoul]]></title>
    <url>%2F2017%2F08%2F01%2FDrawing-and-Song-Tokyo-Ghoul%2F</url>
    <content type="text"><![CDATA[Today I want to share a piece of my drawing and a song of Tokyo Ghoul new movie. The character in the drawing is Kirishima Touka (霧島トーカ), from anime Tokyo Ghoul. And below is the song of Tokyo Ghoul new movie, I like it, the lyric is attached below as well. 「Banka」illion - Tokyo Ghoul 言葉でなんか救えないそんな思いに抱かれしまった全世界が手を繋ぎ僕の行く手を通せんぼする 子供ながらについたあの一世一代の嘘のツケが今になって降ってきたの得意の許され方も通じない 声が聞こえるでしょう知っていたはずだよ悲しみが来た場所君が背をいつも向ける方 愛に凭れないで愛を語らないで無理に振りかざしたりはしないでよなんですぐ頼るのなんで寄りかかるのそんな曖昧なもので片目を塞がないで 同じ酸素を吸ってるのにもう同じ息を吐けない枯れるまでが花なのなら最後までちゃんと燃やすよ 声で交わすよりも手を握りる方がわかることがあるよだから僕らはその手を離すのお喋りが好きなの 愛に凭れないで愛を語らないで無理に振りかざしたりはしないでよなんですぐ頼るのなんで寄りかかるの一生費やしても解ける定理に 愛より大きな声で君は歌う夢より微かな光の中で舞うたとえどれだけその光が醜く輝いていたってさ僕ら選ばれてしまった 愛より大きな声で君は歌う夢より微かな光の中で舞うたとえこの身体も世界も 僕を頑なに拒んでも僕は明日を選ぶ 愛より大きな声で君は歌う夢より微かな光の中で舞うたとえどれだけその光が醜く輝いていたってさ僕ら選ばれてしまった]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>anime</tag>
        <tag>art</tag>
        <tag>drawing</tag>
        <tag>Japanese</tag>
        <tag>song</tag>
        <tag>Tokyo Ghoul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Very Simple Android App - MathSucks]]></title>
    <url>%2F2017%2F07%2F30%2FVery-Simple-Android-App-MathSucks%2F</url>
    <content type="text"><![CDATA[Just want to make a note for this very simple android app, which does percentages. Even though this is super simple, I still had a problem when I run it😅. The problem I had is every TextView, Button, EditText aligned to top left side of the screen. I checked the property of them, all center, it is supposed to work.Then, I realized the default layout is ConstraintLayout, and I tried to change it to RelativeLayout, every widget on the design screen went back to top left side. I dragged them back to the center, aligned them vertically, tried to run it. It worked~~~. Code edited in MainActivity.java1234567891011121314151617181920212223242526272829public class MainActivity extends AppCompatActivity &#123; TextView totalTextView; EditText percentageTxt; EditText numberTxt; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); totalTextView = (TextView) findViewById(R.id.totalTextView); percentageTxt = (EditText) findViewById(R.id.percentageTxt); numberTxt = (EditText) findViewById(R.id.numberTxt); Button calcBtn = (Button) findViewById(R.id.calcBtn); calcBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick (View view) &#123; float percentage = Float.parseFloat(percentageTxt.getText().toString()); float dec = percentage / 100; float total = dec * Float.parseFloat(numberTxt.getText().toString()); totalTextView.setText (Float.toString(total)); &#125; &#125;); &#125; Demo Screens]]></content>
      <categories>
        <category>Computer Science</category>
        <category>App Development</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[نى يېڭىلاش Github Credentials]]></title>
    <url>%2F2017%2F04%2F07%2FUpdating-Credentials-of-Github-in-Uyghur%2F</url>
    <content type="text"><![CDATA[ئەسسالام ئەلەيكۇم تۈنۈگۈن كەچ Github تىكى ھېساۋات نامىمنى ئۆزگەرتكەنىدىم. Github دا ھېسھۋات نامىمنى ئۆزگەرتكەندىنكېن باشتا قۇرغان بەزى ئامبار ۋە گېتخاب بېتىنىڭمۇ url ئادىرسىنىمۇ ئۆزگەرتىش كېرەك ئ‍ىدى. مەن ئۇلانىڭ ھەممىنى ئۆزگەرتىپ ئادىن كومپۇتۇرۇمدىكى hexo بلوگىمنىمۇ تەڭشىدىم. ئاقىدا hexo نى گېتخابقا چىقارماقچى بولغاندا كۈتۈلمىگەن مەسىلىگە يولۇقتۇم. بۇيرۇق كۆزنىكىدە تۆۋەندىكى خاتالىق چىقىۋېلىپ، كومپيۇتىردىكى ئارخىپنى github قا يوللىيالمىدىم. بۇ دېمەك كومپۇتۇرۇم ۋە گىتخابنىڭ ئۇلىنىشىدا مەسەلە كۆرۈلگەنىدى.كۆرۈلگەن مەسىلە: 12FATAL remote: Permission to NewUsername/NewUername.github.io.git denied to Oldusername.fatal: unable to access 'https://github.com/NewUsername/NewUsername.github.io.git/': The requested URL returned error: 403 بۇ مەسەلە ئادەتتە Github تىكى ھېساۋات نامىڭىزنى ئۆزگەتكەندە ۋەياكى بورۇنقىغا ئوخشىمايدىغان گېتخاب ئادىرسىڭىزنى ئىشلەتكەندە كۆرۈلىدۇ. بۇنى ئوڭشاش ئۈچۈن Mac ۋە Windows سېستىمىسىدىكى ئۇسۇللار تۆۋەندىكىچە: Mac1-ئۇسۇل Finder دىن Keychain Access ئەپنى ئىزدەڭ Keychain Access دىن github.com نى ئىزدەڭ ئاندىن شۇكۆزنەكنى ئىشلەتمەكچى بولغان گېتخاب ھېساۋاتىڭىزغا ئاساسەن ئۆزگەرتىش كىرگۈزسىڭىز بولىدۇ. 2-ئۇسۇلسىز terminal ئارقىلىىقمۇ بۇ ئىشەنچە شېفىرىنى ئۈچۈرىۋېتەلەيسىز، ئاندىن سىز گېتخابدا push قىلغاندا ھېساۋات نامىڭىز بىلەن مەخپى-شېفېرىڭىز قايتا سورىلىدۇ.شۇ ۋاقىتتا يېڭىلاتسىڭىزمۇ بولىدۇ. بۇنى قىلىش ئۈچۈن تۆۋەندىكى بۇيرۇقنى كىرگۈزۈڭ. 1234git credential-osxkeychain erasehost=github.comprotocol=https[Press Return] گېتخابدىكى ئېنگىلىىسچە ئەسلى ماتىريالنى كۆرمەكچى بولسىڭىز بۇيەنى چېكىڭ. WindowsWindows تا بىز Credential Manager نى ئىزدەپ github.com نى ئۆچۈرىۋېتىمىز، ئاندىن گېتخابنى ئىشلەتكەندە ھېساۋات-نام بىلەن شېفىر قايتا سورىلىدۇ، يېڭى گېتخاب ئادىرسىڭىز بويىنچە كىرگۈزسىڭىز بولىدۇ. سولتەرەپ تەكتىدىكى ئىزدەش كۆزنىكىدىن Credential Manager نى ئىزدىپ Windows Credential نى تاللاپ github.com نى ئۆچۈرىۋەتسىڭىز بولىدۇ.]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Uyghur</tag>
        <tag>git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ياپونتىلىنى ئۆگېنىش ھەققىدە]]></title>
    <url>%2F2017%2F03%2F28%2FHow-to-Learn-Japanese%2F</url>
    <content type="text"><![CDATA[ئەسسالام ئەلەيكۇم گۆدەك چاغلىرىمدىن باشلاپ تاھازىرغىچە ياپۇنىيەنىڭ كارتۇن فىلىمىنى (ئانىمې) كۆرۈپ كەلدىم. ھەمدە ئانىمې مىنىڭ ھاياتىمغا نۇرغۇن تەرەپلەردىن تەسىر قىلدى، مۇشۇ ئانىمېنى كۈرۈش جەريانىدا ياپون تىلىنىمۇ ئۆگەندىم. شۇڭا بۈگۈن ياپون تىلىنى ئۆگۈنۈشكە ئائىت ئۆزەمنىڭ قارىشىمنى سۆزلەپ ئۆتمەكچىمەن. ياپون تىلى ھەققىدەياپون تىلى بولسا ئۇيغۇرتىلىغا ئوخشاش ئالتاي تىل سىستىمىسىغا تەۋە، ۋىكىپېدىيادا بۇنىڭدىن سىرت يەنە ياپونىك (Japonic) تىل سىستىمىسى دەپمۇ چۈشەندۈرۈپتۇ. ئاناتىلى ئۇيغۇرتىلى بولغان بىز ئۈچۈن ياپون تىلىنى ئۆگۈنۈش خېلىلا ئوڭاي، چۈنكى ياپون تىلىنىڭ جۈملە قۇرۇلمىسىمۇ ئۇيغۇرچىغا ئوخشاش ئگە + تولدۇرغۇچى + پىئىل شەكلىدە قۇرۇلىدۇ. شۇڭلاشقا مېڭىمىزدە تەپەككۈر قىلغاندىكى تەپەككۈر تىلىمىز، يەنى ئۇيغۇرتىلىغىمۇ ماس كېلىدۇ. يەنە كېلىپ بىز خەنزۇ تىلىنىمۇ بىلگەشكە يېزىش ئوقۇش جەھەتتىنمۇ غەرىپ ئەللىرىدىكىلەرگە قارىغاندا ئارتۇقچىلىقىمىز بار. مەقسەت ۋە ھەيدىگۈچسىز ياپۇنتىلىنى ئۆگەنمەكچى بولدىڭىز، ياخشى. تىل ئۆگىنىش بولسا بىر ئۇزۇن مەزگىللىك جەريان. شۇڭا ئۆزىڭىزنىڭ ياپۇن تىلىنى ئۆگۈنۈشتىكى مەقسەتنى ئايدىڭ قىلىپ، ئاندىن ئۆزىڭىزنى ھەيدەپ تۇرۇپ، پىلانىڭىز بىلەن مېڭىپ ئۆگىنىڭ. قىىزىقىش بولسا ئەڭ ياخشى ھەيدىگۈچى كۈچ، بىر ئىقتىدارنى ئۆگۈنۈش جەريانىدا چىن-كۆڭلىڭىزدىن قىزىقسىڭىز ناھايىتى ياخشى ئۆگىنىپ كىتەلەيسىز. ئەلۋەتتە باشقا سىرىتقى ھەيدىگۈچمۇ بولىدۇ، مەسىلەن خىزمەت سەۋەپلىك، مەكتەپتىكى دەرىسلىك سەۋەپلىك دىگەندەك. سىرىتقى سەۋەپلەردىنمۇ ئەلۋەتتە قىزىقىش ھاسىل قىلغىلى بولىدۇ. قۇرۇق گەپنىمۇ جىق قىلدىم، تۆۋەندە تۇرلۇك ماتىرياللارنى چۇشەندۈرۈپ ئۆتەي.😁 ماتىريالدەرىسلىك كىتابمەن みんなの日本語، &lt;&lt;كۆپچىلىكنىڭ ياپونتىلى&gt;&gt; (大家的日语) دىگەن كىتابنى تەۋسىيە قىلىمەن. بۇ كىتابنى ياپوننىڭ تىل مەكتەپلىرىدىمۇ ئۇزۇن يىللاپ قوللىنىپ كەلگەن، بۇرۇن مەن تونۇيدىغان ياپونلۇق مۇئەللىممۇ بۇ كىتابنى بەك ماختايتى، خەنلە چىقاغان ئۆلچەملىك ياپون تىلى(标准日本语) دىگەن كىتابنى ئۇمۇئەللىم قەتتى ياختۇرمايتى. みんなの日本語 جەمى ئىككى قىسىم بولۇپ، ھەربىر قىسمىنىڭ تېكىسىت كىتابى بىلەن ئوقۇغۇچى پايدىلىنىش كىتابى دەپ ئىككى كىتابى بار، جەمى 4 كىتاب بولىدۇ. تېكىسىت كىتىبى تولۇق ياپونچە يېزىلغان تېكىسىت بولۇپ، ئوقۇغۇچى پايدىلىنىش كىتابىدا شۇ تېكىسىت كىتىبىدىكى دىئالوگنىڭ تەرجىمىسى، ئۇچرىغان خام سۆزلەرنىڭ چۇشەندۇرۇلىشى، ۋە گىراماتىكا بار، ئنتايىن چۈشەنچىلىك. سۆزلۈكنىمۇ باشلاشتا مۇشۇ كىتابدىكى سۆزلەرنىلا يادىلىسىڭىز بولىدۇ. ئاندىن فىلىم كۆرگەندە چۈشەنمىگەن ۋەياكى ياختۇرغان سۆز-جۈملىلەرنى خاتىرلىۋالسىڭىز سۆزلۈكىڭىزنى تېخىمۇ مول قىلىدۇ. ئاڭلاش-كۆرۈشيانفۇنىڭىزغا 沪江听力酷 دىگەن ئەپنى چۇشۇرۇپ ئىشلەتسىڭىز بولىدۇ، ھەرخىل تىلنىڭ ھەرخىل تېمىدىكى ئاۋازلىق ماتىرياللىرىنى تاپالايسىز، قولايلىق، مەن ئۆزۇم بۇرۇن مۇشۇنى ئىشلىتەتتىم. ئاندىن みんなの日本語 نىڭ CD دىسكىسىنىمۇ ئاڭلاپ بېرىڭ. ئىسىمدە قېلىشچە 沪江听力酷 دىنمۇ みんなの日本語 نىڭ ئاۋازلىق ماتېريالىنى تاپقىلى بولىدۇ. قوشتىللىق (ياپونچە ۋە خەنزۇچە) خېتى بار ئانىمې ياكى تېلۋىزىيە تېياتىرلىرىنى خېلى جىق توربەتلەردىن تاپقىلى بولىدۇ. مەن ئادەتتە ئانىمې كۆگەشكە ئانىمېگە ئائىتنىلا بىلىدىكەنمە. ئانىمېنىڭ ھەرخىل تىپتىكى ژانراسى بولىدۇ، بۇرۇن كۆرۈپ باقمىغان بولسىڭىزمۇ مىنىڭچە سىز ياختۇردىغان ئانىمې چوقۇم چىقىدۇ. ئەگەر ماڭا ئۆزىڭىز ياخرۇرىدىغان ژانرانى دەپبەرسىڭىز سىزگە بىرياخشى ئانىمې تەۋسىيە قىلالايمەن. 诸神字幕组 天空数字幕组 لۇغەتخۇجىيىڭ تور مەكتىپىنىڭ توربەت لۇغىتىنى ئىشلەتسىڭىز بولىدۇ، بۇيەرنى چىكىپ زىيارەت قىلىڭ. ئەگەر تور بولمىسىمۇ ئىشلەتكىلى بولىدىغان لۇغەت بولسىكە دىسىڭىز ئەپ بازىرىدىن ئىزدەپ بېقىڭ ۋەياكى توۋەندە ئېلخەت ئادىرسىڭىزنى قالدۇرۇپ ئەسكەرىتسىڭىز مەن ئۆزەم ئىشلىتىدىغان ئاددى بىر لۇغەتنى ئەۋەتىپ بەرسەممۇ بولىدۇ، تورلۇغىتىدەك مول بولمىسىمۇ خېلى قولايلىق. مەشىق سوئالみんなの日本語 نىڭ ئىچىدىكى مەشىقلەر ناھايىتى ياخشى، شۇنى ئىشلەپ تولۇق چۇشىنىۋالسىڭىز بولىدۇ. سۆزلەشみんなの日本語 نىڭ ئىچىدىكى دىئالوگنى ئاۋازىڭىزنى چىقىرىپ ئوقۇپ يادىلىسىڭىز بەك ياخشى. ئاندىن بىرە فىلىم كۆگەندىمۇ شۇلانى دوراپ سۆزلىسىڭىزمۇ بولىدۇ. ئەگەر سىز ئالى-مەكتەپ ئوقۇغۇچىسى بولسىڭىز، مەكتىپىڭىزدىكى مەنبەلەردىن ياخشى پايدىلىنىڭ، ئادەتتە ياپونتىلى كەسپى بارلا مەكتەپ بولسا، بىر نەچچە نەپەر ياپونلۇق مۇئەللىم ئېنىقلام بار. شۇلانى ئىزدەپ چۈشەندۇرۈپ پاراڭلىشىڭ، ھەتتا دەرىسىگىمۇ قاتنىشالايسىز. بەكلام پادىسى بولىدۇ، ياپونلۇق مۇئەللىممۇ سىزنى ئۆز ئۇقۇغۇچىسىدەك كۆرۈپ ياردەم قىلىشى،مۇڭدىشىشى مۇمكىن. مەنمۇ ئەينى ۋاقىتتا شۇندا قىلىپ ياپونتىلى كەسپىنىڭ 3، 4 چى يىللىقتىكىلەرنىڭ دەرىسىنى ئېلىۋالغان ئىدىم.ئىشقىپ مەنبەنى ياخشى قەدىرلەڭ! دۆلەت ئىچىدە ئوقۇشقا كېتىدىغان خىراجەت بەكلام ئەرزان، ئامرىكىدەك يەرگە كەلسىڭىز، دەرىسلىك كىتابنىمۇ ئېلىشقا قۇربىڭىز يەتمەسلىكى ناھايىتى نورمال ئىش، بىر دەرىسلىك كىتاب قىممەت بولغاندا ھەتتا دولەتتىكى ئالى-مەكتەپنىڭ بىر يىللىق ئوقۇش پۇلىغىمۇ تەڭ بولالايدۇ. راس گەپ! 800 دوللارلىق كىتابنى كۆرەپ، بۇرۇن بىلىمنىڭ قانچىلىك ئەرزانچىلىق يەردە تۇرغانلىقىنى ھېس قىلغان ئدىم.😅 نىشان ۋە پىلانتىلنى ئۆگىنىپ ۋايىغا يەتكۈمىگىچە قەرەرلىك ئۆگۈنۈپ تەكرارلاپ تۇرمىسا ئادەم ئاسانلا ئۇنتۇيدۇ. شۇقا بۇ مۇساپىنى بېسىپ چىقىش ئۈچۈن، نىشاننى بېكىتىپ قەرەرلىك ئۆگۈنۇپ تۇرشىڭىز كېرەك. مەسىلەن توۋەندىكىدەك پىلان تۈزۇپ، ئۆزىڭىز بىكىتكەن ۋاقىتتا ئورۇنلاپ ماڭسىڭىز ناھايىتى ياخشى. مەسىلەن قىسقا مۇددەتلىك نىشاننى بىر ھەپتىدە، ئوتتۇرا مۇددەتلىكنى بىر ئايدا، ئۇزۇن مۇددەتلىك پىلاننى بىر يىلدا ئورۇنلاپ چىقىش دىگەندەك. ئەمدى ۋاقىت ئارلىقىنى ئۆزىڭىزنىڭ ئەھۋالىغا قاۋاپ بېكىتىڭ، قەرەرلىك داۋاملشتۇرۇش ئەڭ مۇھىم. قىسقا مۇددەتلىك نىشان ياپونتىلى ئۆگىنىش كىتابىدىن بىر دەرىس ئۆگىنىش 100 تال يېڭى سۆزلۈك ئوگىنىش ئوقۇلما: بىر ئادىراق ياشلار مانگاسىنى ئوقۇش. (ياپۇننىڭ چاتما رەسىملىك كارتون كىتابلىرى، 少年漫画). فىلىم: تەكتىدە ياپونچە خىتى بار ئانىمېدىن 5 قىسىم كۆرۇش ياكى ياپوننىڭ تېلۋىزىيە تىياتېرلىرىنى كۆرسىڭىزمۇ بولىدۇ، ھەم ياختۇرغان جۇملە سۆزلەرنى كۆرەپ بولۇپ خاتىرلىۋېلىش. ئوتتۇرا مۇددەتلىك نىشان بىر دەرىسلىك كىتابنى تۈگىتىش بىر روماننى ئوقۇپ تۈگىتىش بۇرۇن ئوقۇغان مانگانى قايتا ئوقۇپ چىقىش 3000 سۆزلۈك ئۆگىنىش بىر بۆلۇم تەكتىدە ياپونچە خىتى يوق ئانىمې كۈرۈش ئۇزۇن مۇددەتلىك نىشان تەكتىدە خېتى يوق ياكى پەقەتلا ياپونچە خېتى بار ئانىمېنى كورۈپ چۇشىنىش. مانگا ياكى روماننى ئوقۇپ چۈشىنىش ياپونتىلىنى تەرجىمە قىلالاش ياپونچە پاراڭلىشالاش. ئاخىرىدائەگەر ياپونتىلىغا ئائىت بىرە سوئاللا بولسا، ئىنكاس رايونىدا خەت قالدۇرۇپ سورىسىڭىز بولىدۇ.😀]]></content>
      <categories>
        <category>Language &amp; Literature</category>
        <category>Japanese</category>
      </categories>
      <tags>
        <tag>language</tag>
        <tag>Japanese</tag>
        <tag>tutorial</tag>
        <tag>Uyghur</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
